<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slots</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            margin: 0;
            color: #e2e8f0; /* Light text color */
            padding: 20px;
            box-sizing: border-box;
        }

        .coin-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2em;
            background-color: #4a5568; /* Slightly lighter dark grey */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 100;
        }

        .game-container {
            background-color: #2d3748; /* Darker grey */
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            text-align: center;
            width: 90%;
            max-width: 700px; /* Adjust max-width for a wider grid */
        }

        h1 {
            color: #4299e1; /* Blue */
            margin-bottom: 30px;
            font-size: 2.8em;
        }

        .slot-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr); /* 6 columns */
            grid-template-rows: repeat(6, 1fr); /* 6 rows */
            gap: 5px; /* Gap between symbols */
            width: 100%;
            aspect-ratio: 1 / 1; /* Keep grid square */
            background-color: #1a202c;
            border: 5px solid #4a5568;
            border-radius: 8px;
            padding: 5px;
            margin: 30px auto;
        }

        /* --- Symbol Styling --- */
        .symbol {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4a5568; /* Default symbol background */
            border-radius: 5px;
            font-size: 2em; /* Adjust font size for symbols */
            font-weight: bold;
            color: #cbd5e0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.1s ease-in-out, transform 0.1s ease-in-out, opacity 0.3s ease-out; /* Added opacity transition */
            user-select: none; /* Prevent text selection on symbols */
            position: relative; /* Needed for absolute positioning during drop animation */
        }

        .symbol.highlight {
            background-color: #48bb78; /* Green for winning symbols */
            transform: scale(1.05);
        }

        /* Styles for symbols disappearing */
        .symbol.fade-out {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none; /* Make it unclickable while fading out */
        }

        /* Styles for symbols dropping down */
        .symbol.dropping {
            transition: transform 0.3s ease-out, opacity 0.3s ease-out; /* Smooth drop */
        }


        .game-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for responsiveness */
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        .bet-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: #4a5568;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .bet-control label {
            font-size: 1.1em;
        }

        .bet-control input[type="number"] {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e2e8f0;
            font-size: 1em;
            width: 70px;
            text-align: center;
        }

        .game-controls button {
            background-color: #4299e1; /* Blue */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .game-controls button:hover:not(:disabled) {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-2px);
        }

        .game-controls button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .game-controls button:disabled {
            background-color: #718096; /* Disabled color */
            cursor: not-allowed;
            box-shadow: none;
        }

        #buyFreeSpinsBtn {
            background-color: #d69e2e; /* Orange for buy free spins */
        }

        #buyFreeSpinsBtn:hover:not(:disabled) {
            background-color: #b7791f; /* Darker orange on hover */
        }

        .message, .win-message {
            font-size: 1.3em;
            font-weight: bold;
            min-height: 1.5em; /* Prevent layout shift */
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .message {
            color: #e2e8f0;
        }

        .win-message {
            color: #48bb78; /* Green for win messages */
        }

        .free-spin-info {
            color: #f6ad55; /* Orange for free spin info */
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }

        .back-button {
            background-color: #718096;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .back-button:hover {
            background-color: #5a67d8;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="coin-display" onclick="window.location.href='Buy_coins.html'">
        Coins: <span id="coinCount"></span>
    </div>

    <div class="game-container">
        <h1>Le Bandit Slots</h1>

        <div class="slot-grid" id="slotGrid">
            </div>

        <div class="game-controls">
            <div class="bet-control">
                <label for="betAmount">Bet:</label>
                <input type="number" id="betAmount" value="10" min="1" max="1000">
                <button id="setBetBtn">Set Bet</button>
            </div>
            <button id="spinBtn">Spin</button>
            <button id="buyFreeSpinsBtn">Buy Free Spins (5000 Coins)</button>
        </div>

        <p id="message" class="message"></p>
        <p id="winMessage" class="win-message"></p>
        <p id="freeSpinCount" class="free-spin-info hidden"></p>

        <button class="back-button" onclick="window.history.back()">Go Back</button>
    </div>

    <script>
        // --- Game variables ---
        let coins = parseInt(localStorage.getItem('coins') || '1000');
        let currentBetAmount = 10;
        let freeSpinCount = 0;
        let isSpinning = false;
        let autoSpinActive = false;
        let currentGridState = [];

        // --- Provably Fair variables ---
        let clientSeed = generateRandomString(16); // Generated once on page load
        let spinNonce = 0; // Increments with each spin
        const SERVER_SEED_HASH_PLACEHOLDER = "d404f215-fixed-hash-for-demo"; // In a real game, this would be a real hash from the server

        // --- DOM elements ---
        const coinCountDisplay = document.getElementById('coinCount');
        const slotGrid = document.getElementById('slotGrid');
        const betAmountInput = document.getElementById('betAmount');
        const setBetBtn = document.getElementById('setBetBtn');
        const spinBtn = document.getElementById('spinBtn');
        const buyFreeSpinsBtn = document.getElementById('buyFreeSpinsBtn');
        const messageEl = document.getElementById('message');
        const winMessageEl = document.getElementById('winMessage');
        const freeSpinCountEl = document.getElementById('freeSpinCount');

        // --- Game Configuration ---
        const SYMBOLS = ['üçé', 'üçã', 'üçí', 'üîî', '‚≠ê', '7Ô∏è‚É£', 'üç≠']; // Regular symbols
        const SCATTER_SYMBOL = 'FS'; // Free Spin symbol
        const EMPTY_SPOT = ''; // Represents an empty spot after a win
        const GRID_SIZE = 6; // 6x6 grid

        // Define payouts for connecting symbols (example values, you can adjust these)
        const PAYOUTS = {
            'üçé': [0, 0, 0, 0, 0, 0.5, 0.7, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 16],
            'üçã': [0, 0, 0, 0, 0, 0.6, 0.8, 1.2, 1.8, 2.2, 2.8, 3.2, 3.8, 4.2, 4.8, 5.2, 5.8, 6.2, 6.8, 7.2, 7.8, 8.2, 8.8, 9.2, 9.8, 10.2, 10.8, 11.2, 11.8, 12.2, 12.8, 13.2, 13.8, 14.2, 14.8, 15.2, 17],
            'üçí': [0, 0, 0, 0, 0, 0.7, 0.9, 1.4, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 15.5, 18],
            'üîî': [0, 0, 0, 0, 0, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 15.5, 16, 20],
            '‚≠ê': [0, 0, 0, 0, 0, 1.2, 1.8, 2.4, 3, 3.6, 4.2, 4.8, 5.4, 6, 6.6, 7.2, 7.8, 8.4, 9, 9.6, 10.2, 10.8, 11.4, 12, 12.6, 13.2, 13.8, 14.4, 15, 15.6, 16.2, 16.8, 17.4, 18, 18.6, 19.2, 25],
            '7Ô∏è‚É£': [0, 0, 0, 0, 0, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 15.5, 16, 16.5, 30],
            'üç≠': [0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 50]
        };

        // --- Utility Functions ---

        // Helper to generate a random string for client seed
        function generateRandomString(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        function updateCoinDisplay() {
            coinCountDisplay.textContent = coins;
            localStorage.setItem('coins', coins);
        }

        function updateFreeSpinDisplay() {
            if (freeSpinCount > 0) {
                freeSpinCountEl.textContent = `Free Spins Remaining: ${freeSpinCount}`;
                freeSpinCountEl.classList.remove('hidden');
            } else {
                freeSpinCountEl.classList.add('hidden');
            }
        }

        function displayMessage(msg) {
            messageEl.textContent = msg;
            winMessageEl.textContent = '';
            messageEl.classList.remove('win');
        }

        function displayWinMessage(msg) {
            winMessageEl.textContent = msg;
            messageEl.textContent = '';
            winMessageEl.classList.add('win');
        }

        function generateInitialGrid() {
            slotGrid.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const symbolDiv = document.createElement('div');
                symbolDiv.classList.add('symbol');
                symbolDiv.textContent = '?';
                slotGrid.appendChild(symbolDiv);
            }
        }

        function getRandomSymbol(isFreeSpin = false) {
            const allSymbols = [...SYMBOLS];
            // Make free spins less common: 3% chance for FS symbol on a regular spin
            if (!isFreeSpin && Math.random() < 0.03) {
                return SCATTER_SYMBOL;
            }
            const randomIndex = Math.floor(Math.random() * allSymbols.length);
            return allSymbols[randomIndex];
        }

        // Helper for BFS
        function isValid(r, c) {
            return r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE;
        }

        function getNeighbors(r, c) {
            const neighbors = [];
            // Up, Down, Left, Right
            if (isValid(r - 1, c)) neighbors.push([r - 1, c]);
            if (isValid(r + 1, c)) neighbors.push([r + 1, c]);
            if (isValid(r, c - 1)) neighbors.push([r, c - 1]);
            if (isValid(r, c + 1)) neighbors.push([r, c + 1]);
            return neighbors;
        }

        /**
         * Finds connected clusters of symbols in the grid.
         * @param {Array<Array<string>>} grid The 2D array representing the current grid state.
         * @returns {{winningCells: Set<string>, scatterCount: number, totalPayout: number}}
         */
        function findConnections(grid) {
            const visited = new Set();
            const winningCells = new Set();
            let currentCascadePayout = 0;
            let scatterCount = 0;

            const processingGrid = grid.map(row => [...row]); // Deep clone

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const currentSymbol = processingGrid[r][c];
                    const cellId = `${r}-${c}`;

                    if (currentSymbol === EMPTY_SPOT || visited.has(cellId)) {
                        continue;
                    }

                    if (currentSymbol === SCATTER_SYMBOL) {
                        scatterCount++;
                        visited.add(cellId);
                        continue;
                    }

                    const cluster = new Set();
                    const queue = [[r, c]];
                    visited.add(cellId);
                    cluster.add(cellId);

                    let head = 0;
                    while (head < queue.length) {
                        const [currR, currC] = queue[head++];
                        
                        for (const [nR, nC] of getNeighbors(currR, currC)) {
                            const neighborSymbol = processingGrid[nR][nC];
                            const neighborId = `${nR}-${nC}`;

                            if (neighborSymbol === currentSymbol && !visited.has(neighborId)) {
                                visited.add(neighborId);
                                cluster.add(neighborId);
                                queue.push([nR, nC]);
                            }
                        }
                    }

                    if (cluster.size >= 5) { // Payouts for 5 or more connected symbols
                        const payoutMultiplier = PAYOUTS[currentSymbol] ? PAYOUTS[currentSymbol][cluster.size] : 0;
                        if (payoutMultiplier > 0) {
                            currentCascadePayout += currentBetAmount * payoutMultiplier;
                            cluster.forEach(id => winningCells.add(id));
                        }
                    }
                }
            }
            return { winningCells, scatterCount, totalPayout: currentCascadePayout };
        }

        /**
         * Visually removes winning symbols, applies gravity, and fills new symbols.
         * Updates both the logical grid and the DOM elements.
         * @param {Array<Array<string>>} grid The 2D grid state (modified in place).
         * @param {Set<string>} winningCells Set of "r-c" strings of symbols to remove.
         * @param {HTMLElement[]} symbolElements All symbol DOM elements.
         * @returns {Promise<void>} A promise that resolves after removal and drop animations.
         */
        function removeAndDropSymbols(grid, winningCells, symbolElements) {
            console.log("removeAndDropSymbols: Initiating.");
            return new Promise(resolve => {
                const elementsToClear = new Set(); // Elements whose content will disappear
                winningCells.forEach(id => {
                    const [r, c] = id.split('-').map(Number);
                    const index = r * GRID_SIZE + c;
                    elementsToClear.add(symbolElements[index]);
                    grid[r][c] = EMPTY_SPOT; // Mark as empty in logical grid
                });

                // 1. Animate removal (fade out winning symbols)
                console.log(`removeAndDropSymbols: Fading out ${elementsToClear.size} winning symbols.`);
                elementsToClear.forEach(el => {
                    el.classList.add('fade-out');
                    el.classList.remove('highlight'); // Remove highlight immediately for visual clarity
                });

                // Wait for fade-out animation to complete
                setTimeout(() => {
                    elementsToClear.forEach(el => {
                        el.textContent = EMPTY_SPOT; // Clear content after fade
                        el.classList.remove('fade-out'); // Remove fade class
                        el.style.backgroundColor = ''; // Reset background
                    });
                    console.log("removeAndDropSymbols: Fade out complete, clearing text content.");

                    const dropPromises = [];

                    // 2. Apply gravity: shift existing symbols down
                    for (let c = 0; c < GRID_SIZE; c++) {
                        let emptySpotsInCol = 0;
                        // Iterate from bottom up
                        for (let r = GRID_SIZE - 1; r >= 0; r--) {
                            if (grid[r][c] === EMPTY_SPOT) {
                                emptySpotsInCol++;
                            } else if (emptySpotsInCol > 0) {
                                // A symbol found, and there are empty spots below it
                                const originalSymbol = grid[r][c];
                                const originalElementIndex = r * GRID_SIZE + c;
                                const originalElement = symbolElements[originalElementIndex];

                                const newR = r + emptySpotsInCol; // New row for the symbol
                                const newElementIndex = newR * GRID_SIZE + c;
                                const newElement = symbolElements[newElementIndex];

                                // Logically move the symbol
                                grid[newR][c] = originalSymbol;
                                grid[r][c] = EMPTY_SPOT; // Mark original spot as empty

                                // Visually move the symbol by transferring its content and animating the target
                                newElement.textContent = originalSymbol;
                                newElement.style.backgroundColor = originalElement.style.backgroundColor; // Keep color
                                newElement.classList.add('dropping');
                                originalElement.textContent = EMPTY_SPOT; // Clear old position
                                originalElement.style.backgroundColor = '';

                                // Set initial position for drop animation (offscreen above the target)
                                // Calculate distance based on symbol height + gap
                                const dropDistance = emptySpotsInCol * (newElement.offsetHeight + 5);
                                newElement.style.transform = `translateY(-${dropDistance}px)`;
                                newElement.style.opacity = '0'; // Start invisible

                                // Trigger reflow to ensure initial transform is applied before animating
                                void newElement.offsetWidth;

                                // Animate to final position
                                newElement.style.transform = 'translateY(0)';
                                newElement.style.opacity = '1';

                                dropPromises.push(new Promise(res => {
                                    newElement.addEventListener('transitionend', function handler() {
                                        newElement.classList.remove('dropping');
                                        newElement.removeEventListener('transitionend', handler);
                                        res();
                                    }, { once: true });
                                }));
                                console.log(`removeAndDropSymbols: Symbol ${originalSymbol} at ${r},${c} logically moved to ${newR},${c} (visual drop initiated).`);
                                isSpinning = false;

                            }
                        }
                    }

                    // 3. Fill new symbols from the top
                    for (let c = 0; c < GRID_SIZE; c++) {
                        for (let r = 0; r < GRID_SIZE; r++) {
                            if (grid[r][c] === EMPTY_SPOT) {
                                const newSymbol = getRandomSymbol(freeSpinCount > 0);
                                grid[r][c] = newSymbol;
                                const index = r * GRID_SIZE + c;
                                const newSymbolElement = symbolElements[index];

                                newSymbolElement.textContent = newSymbol;
                                newSymbolElement.style.backgroundColor = ''; // Reset to default background
                                newSymbolElement.classList.add('dropping');

                                // Set initial position for new symbol to drop in from above the grid
                                const dropHeight = (r + 1) * (newSymbolElement.offsetHeight + 5); // Based on row number
                                newSymbolElement.style.transform = `translateY(-${dropHeight}px)`;
                                newSymbolElement.style.opacity = '0';

                                // Trigger reflow
                                void newSymbolElement.offsetWidth;

                                // Animate to final position
                                setTimeout(() => { // Small delay for visual separation from previous drops
                                    newSymbolElement.style.transform = 'translateY(0)';
                                    newSymbolElement.style.opacity = '1';
                                }, 50); // A small delay to ensure visual order

                                dropPromises.push(new Promise(res => {
                                    newSymbolElement.addEventListener('transitionend', function handler() {
                                        newSymbolElement.classList.remove('dropping');
                                        newSymbolElement.removeEventListener('transitionend', handler);
                                        res();
                                    }, { once: true });
                                }));
                                console.log(`removeAndDropSymbols: New symbol ${newSymbol} filling empty spot at ${r},${c} (visual drop-in initiated).`);
                                isSpinning = false;

                            }
                        }
                    }
                    
                    // Resolve the main promise after all drops are complete
                    Promise.all(dropPromises).then(() => {
                        console.log("removeAndDropSymbols: All drop animations complete.");
                        resolve();
                        isSpinning = false;

                    });

                }, 300); // Wait for fade-out animation
            });
        }

        async function processSpinResults(grid, symbolElements) {
            let totalSessionWin = 0;
            let freeSpinsAwardedThisSession = 0;
            let cascadeCounter = 0;
            let currentScatterCount = 0; // Track scatters across cascades

            currentGridState = grid; // Ensure this is the grid we're working on

            while (true) {
                cascadeCounter++;
                console.log(`--- Cascade ${cascadeCounter} Started ---`);
                
                try { // Added try-catch for debugging and recovery
                    if (!currentGridState || !Array.isArray(currentGridState) || currentGridState.length === 0) {
                        console.error("ERROR: currentGridState is invalid or empty at cascade start.", currentGridState);
                        break; // Exit if grid is bad
                    }
                    console.log("Current Grid State at cascade start:");
                    currentGridState.forEach((row, rowIndex) => {
                        if (!Array.isArray(row)) {
                            console.error(`ERROR: Row ${rowIndex} in currentGridState is not an array:`, row);
                            // Re-throw to be caught by the outer try-catch
                            throw new Error("Invalid grid row format. Cannot join row."); 
                        }
                        console.log(row.join('|'));
                    });

                    // Always re-evaluate scatters in the current grid state for each cascade
                    let tempScatterCount = 0;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (currentGridState[r][c] === SCATTER_SYMBOL) {
                                tempScatterCount++;
                            }
                        }
                    }
                    currentScatterCount = tempScatterCount; // Update total scatter count
                    console.log(`Scatters detected: ${currentScatterCount}`);

                    const { winningCells, totalPayout } = findConnections(currentGridState);
                    console.log(`findConnections result: Winning Cells Count = ${winningCells.size}, Payout = ${totalPayout.toFixed(2)}`);

                    if (winningCells.size === 0 && (currentScatterCount < 3 || freeSpinsAwardedThisSession > 0)) {
                        // No more wins AND either not enough new scatters OR free spins already awarded (prevents re-awarding)
                        console.log(`Cascade ${cascadeCounter} ending: No new wins or free spins criteria met.`);
                        break;
                    }

                    // Award free spins only once per initial spin if threshold met
                    if (currentScatterCount >= 3 && freeSpinsAwardedThisSession === 0) {
                        const awardedSpins = 8;
                        freeSpinCount += awardedSpins;
                        freeSpinsAwardedThisSession += awardedSpins;
                        displayWinMessage(`You got ${currentScatterCount} FS symbols! Awarded ${awardedSpins} Free Spins!`);
                        updateFreeSpinDisplay();
                        console.log(`Free Spins Awarded: ${awardedSpins}. Total freeSpinCount: ${freeSpinCount}`);
                        // Don't break yet if there are also symbol wins, continue cascading if any
                    } else if (totalPayout > 0) {
                        displayWinMessage(`Win: ${totalPayout.toFixed(2)} coins! Total: ${totalSessionWin.toFixed(2)}`);
                        console.log(`Symbol win detected: ${totalPayout.toFixed(2)} coins.`);
                    }


                    // Apply highlights to winning symbols for current cascade
                    if (winningCells.size > 0) {
                        console.log(`Highlighting ${winningCells.size} winning cells.`);
                        winningCells.forEach(id => {
                            const [r, c] = id.split('-').map(Number);
                            const index = r * GRID_SIZE + c;
                            symbolElements[index].classList.add('highlight');
                        });
                        totalSessionWin += totalPayout; // Add payout from this specific cascade

                        // Wait for symbol removal and drop animations
                        console.log("Waiting for fade-out and drop animations...");
                        await new Promise(resolve => setTimeout(resolve, 500)); // Short pause before removal animation
                        await removeAndDropSymbols(currentGridState, winningCells, symbolElements);
                        console.log("Fade-out and drop animations complete.");
                        await new Promise(resolve => setTimeout(resolve, 300)); // Pause after drop to see new grid
                    } else {
                        // No new wins from symbols, so break cascade (scatters handled above)
                        console.log(`Cascade ${cascadeCounter} ending: No symbol wins to process.`);
                        break;
                    }
                    
                    // Clear highlights for the next cascade check before looping
                    symbolElements.forEach(el => el.classList.remove('highlight'));
                } catch (error) {
                    console.error(`CRITICAL ERROR in processSpinResults at cascade ${cascadeCounter}:`, error);
                    // Ensure buttons are re-enabled if an error occurs and spin is stuck
                    isSpinning = false;
                    autoSpinActive = false;
                    spinBtn.disabled = false;
                    setBetBtn.disabled = false;
                    buyFreeSpinsBtn.disabled = false;
                    displayMessage("An error occurred during spin processing. Please try again.");
                    break; // Exit the while loop
                }
            }

            // Final message after all cascades are done
            if (totalSessionWin > 0) {
                coins += totalSessionWin;
                displayWinMessage(`Total Win: ${totalSessionWin.toFixed(2)} coins!`);
            } else if (freeSpinsAwardedThisSession > 0) {
                 displayMessage(`Free spins awarded! Initiating free spin sequence...`);
            } else {
                displayMessage("No win this spin. Try again!");
            }

            updateCoinDisplay();
            console.log(`--- All cascades for this spin completed. Total Session Win: ${totalSessionWin.toFixed(2)} ---`);
        }

        async function spinReels() {
            if (isSpinning) return; // Prevent multiple spins at once

            // Check if enough coins for a regular spin OR if free spins are available
            if (freeSpinCount === 0 && coins < currentBetAmount) {
                displayMessage("Not enough coins to spin! Adjust your bet or buy more coins.");
                return;
            }

            isSpinning = true;
            spinBtn.disabled = true; // Disable manual spin button
            setBetBtn.disabled = true;
            buyFreeSpinsBtn.disabled = true;
            messageEl.textContent = "Spinning...";
            winMessageEl.textContent = '';

            try {
                // Deduct coins or free spin
                if (freeSpinCount === 0) {
                    coins -= currentBetAmount;
                    updateCoinDisplay();
                } else {
                    freeSpinCount--;
                    updateFreeSpinDisplay();
                }
                console.log(`Spin initiated. Free Spin Count: ${freeSpinCount}`);

                // --- Provably Fair Information Logging ---
                spinNonce++; // Increment nonce for each spin
                const currentSpinSeed = `${clientSeed}-${SERVER_SEED_HASH_PLACEHOLDER}-${spinNonce}`; // Example combined seed
                console.log(`\n--- Provably Fair Info for Spin ${spinNonce} ---`);
                console.log(`Client Seed: ${clientSeed}`);
                console.log(`Server Seed Hash (Pre-Reveal): ${SERVER_SEED_HASH_PLACEHOLDER}`);
                console.log(`Spin Nonce: ${spinNonce}`);
                console.log(`Combined Spin Seed: ${currentSpinSeed}`);
                console.log("---------------------------------------");

                const symbolElements = Array.from(slotGrid.children);
                // Clear all animation/highlighting classes and reset styles before new spin
                symbolElements.forEach(el => {
                    el.classList.remove('highlight', 'fade-out', 'dropping');
                    el.style.transform = '';
                    el.style.opacity = '1';
                    el.style.backgroundColor = '';
                });

                const spinAnimationDuration = 1000;
                const revealInterval = 50;

                let spinAnimation = setInterval(() => {
                    symbolElements.forEach(el => {
                        el.textContent = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
                        el.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
                    });
                }, revealInterval);

                await new Promise(resolve => setTimeout(resolve, spinAnimationDuration));
                clearInterval(spinAnimation);
                console.log("Spin animation completed. Generating initial grid.");

                let initialSpinGrid = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    let row = [];
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const symbol = getRandomSymbol(freeSpinCount > 0); // Passes if current spin is a free spin
                        row.push(symbol);
                        const index = r * GRID_SIZE + c;
                        symbolElements[index].textContent = symbol;
                        symbolElements[index].style.backgroundColor = '';
                    }
                    initialSpinGrid.push(row);
                }
                currentGridState = initialSpinGrid;
                console.log("Initial Spin Outcome (Generated Grid):");
                currentGridState.forEach(row => console.log(row.join('|')));
                console.log("Processing results...");

                await processSpinResults(currentGridState, symbolElements);

                isSpinning = false; // Spin has visually finished and results processed
                console.log(`Spin processing complete. Remaining free spins: ${freeSpinCount}. Auto-spin active: ${autoSpinActive}.`);

                // Auto-spin logic for free spins
                if (freeSpinCount > 0) {
                    autoSpinActive = true;
                    displayMessage(`Free Spin! Next spin in 2 seconds...`);
                    console.log("Auto-spin initiated.");
                    setTimeout(() => {
                        if (freeSpinCount > 0) { // Double check in case user clicked away or something
                            spinReels(); // Recursively call for next free spin
                        } else {
                            // If free spins ran out during the delay
                            autoSpinActive = false;
                            spinBtn.disabled = false;
                            setBetBtn.disabled = false;
                            buyFreeSpinsBtn.disabled = false;
                            if (winMessageEl.textContent === '') { // Only if no win message is already showing
                                displayMessage("Spin again!");
                            }
                            console.log("Free spins exhausted during delay, re-enabling buttons.");
                        }
                    }, 2000); // 2 second delay between free spins
                } else {
                    // If no more free spins or was a regular spin, re-enable buttons
                    autoSpinActive = false; // Ensure it's false
                    spinBtn.disabled = false;
                    setBetBtn.disabled = false;
                    buyFreeSpinsBtn.disabled = false;
                    if (winMessageEl.textContent === '') { // Only if no win message is already showing
                         displayMessage("Spin again!");
                    }
                    console.log("No free spins remaining, re-enabling buttons.");
                }
            } catch (error) {
                console.error("Spin error:", error);
                displayMessage("An error occurred. Please try again.");
            } finally {
                // Always re-enable buttons if not in auto-spin/free spin mode
                if (!autoSpinActive && freeSpinCount === 0) {
                    isSpinning = false;
                    spinBtn.disabled = false;
                    setBetBtn.disabled = false;
                    buyFreeSpinsBtn.disabled = false;
                }
            }
        }

        // --- Developer Console Tools (Global Functions) ---
        window.getCoins = function() {
            console.log(`Current Coins: ${coins}`);
            return coins;
        };

        window.editCoins = function(amount) {
            if (typeof amount !== 'number') {
                console.error("editCoins: Amount must be a number.");
                return;
            }
            coins += amount;
            updateCoinDisplay();
            console.log(`Coins adjusted by ${amount}. New balance: ${coins}`);
        };

        window.getFreeSpins = function() {
            console.log(`Current Free Spins: ${freeSpinCount}`);
            return freeSpinCount;
        };

        window.editFreeSpins = function(amount) {
            if (typeof amount !== 'number') {
                console.error("editFreeSpins: Amount must be a number.");
                return;
            }
            freeSpinCount = Math.max(0, freeSpinCount + amount); // Ensure free spins don't go below 0
            updateFreeSpinDisplay();
            console.log(`Free Spins adjusted by ${amount}. New count: ${freeSpinCount}`);
        };

        window.getBet = function() {
            console.log(`Current Bet: ${currentBetAmount}`);
            return currentBetAmount;
        };

        window.setBet = function(amount) {
            if (typeof amount !== 'number' || amount <= 0) {
                console.error("setBet: Bet amount must be a positive number.");
                return;
            }
            if (amount > coins) {
                console.warn(`setBet: Not enough coins (${coins}) for requested bet (${amount}). Bet not set.`);
                displayMessage("You don't have enough coins for that bet!");
                return;
            }
            currentBetAmount = amount;
            betAmountInput.value = amount; // Update input field
            // Re-check setBetBtn disabled state based on new value
            setBetBtn.disabled = (parseInt(betAmountInput.value) <= 0 || parseInt(betAmountInput.value) > coins);
            console.log(`Bet set to: ${currentBetAmount}.`);
            displayMessage(`Bet set to ${currentBetAmount}. Good luck!`);
        };

        // NEW: Client Seed Management Commands
        window.getClientSeed = function() {
            console.log(`Current Client Seed: ${clientSeed}`);
            return clientSeed;
        };

        window.refreshClientSeed = function() {
            clientSeed = generateRandomString(16); // Generate a new 16-character string
            spinNonce = 0; // Reset spin nonce for the new seed
            console.log(`Client Seed refreshed. New Client Seed: ${clientSeed}`);
            console.log(`Spin Nonce reset to ${spinNonce}.`);
            displayMessage("Client seed refreshed! New game sequence started.");
        };


        // --- Event Listeners ---
        setBetBtn.addEventListener('click', () => {
            let newBet = parseInt(betAmountInput.value);
            if (isNaN(newBet) || newBet <= 0) {
                displayMessage("Please enter a valid bet amount (must be positive).");
                return;
            }
            if (newBet > coins) {
                displayMessage("You don't have enough coins for that bet!");
                return;
            }
            currentBetAmount = newBet;
            displayMessage(`Bet set to ${currentBetAmount}. Good luck!`);
            // Only enable spin if not in an auto-spin sequence
            if (!autoSpinActive) {
                spinBtn.disabled = false;
            }
            console.log(`Bet set to: ${currentBetAmount}.`);
        });

        betAmountInput.addEventListener('input', () => {
            const value = parseInt(betAmountInput.value);
            // Disable set bet button only if input is invalid or insufficient coins
            setBetBtn.disabled = (isNaN(value) || value <= 0 || value > coins);
        });

        spinBtn.addEventListener('click', spinReels);

        buyFreeSpinsBtn.addEventListener('click', () => {
            const freeSpinCost = 5000;
            if (coins >= freeSpinCost) {
                coins -= freeSpinCost;
                freeSpinCount += 8;
                updateCoinDisplay();
                updateFreeSpinDisplay();
                displayMessage(`You bought 8 free spins for ${freeSpinCost} coins!`);
                // Only enable spin if not in an auto-spin sequence
                if (!autoSpinActive) {
                    spinBtn.disabled = false;
                }
                console.log(`Bought 8 free spins. Total freeSpinCount: ${freeSpinCount}`);
            } else {
                displayMessage(`You need ${freeSpinCost} coins to buy free spins!`);
                console.log(`Failed to buy free spins. Need ${freeSpinCost}, have ${coins}.`);
            }
        });

        // --- Initial Setup ---
        window.onload = () => {
            updateCoinDisplay();
            generateInitialGrid();
            updateFreeSpinDisplay();
            spinBtn.disabled = true; // Disable spin button initially
            // Check initial bet amount input for validity
            setBetBtn.disabled = (parseInt(betAmountInput.value) <= 0 || parseInt(betAmountInput.value) > coins);
            console.log("Game initialized.");
        };
    </script>
</body>
</html>
