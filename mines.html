<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mines Game</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2d3748; /* Darker grey */
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #4299e1; /* Blue */
            margin-bottom: 25px;
            font-size: 2.5em;
        }

        .coin-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2em;
            background-color: #4a5568; /* Slightly lighter dark grey */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 100; /* Ensure it's on top */
        }

        /* New styles for Live Stats Button */
        #liveStatsButton {
            position: absolute;
            top: 25px;
            right: 250px; /* Adjust as needed to not overlap with coin display */
            background-color: #4299e1; /* Blue */
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            opacity: 0.7; /* A bit opaque */
            transition: opacity 0.2s ease, background-color 0.2s ease;
            z-index: 100; /* Ensure it's on top */
        }

        #liveStatsButton:hover {
            opacity: 1;
            background-color: #3182ce;
        }

        /* NEW: Styles for the movable modal */
        .modal-overlay {
            /* This will be the movable window itself */
            position: absolute; /* Changed from fixed to absolute */
            display: block; /* Will be toggled with 'hidden' class */
            z-index: 1000; /* Ensure it's on top */
            background-color: #2d3748; /* Darker grey, same as modal-content before */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            width: 90%; /* Keep this for responsiveness */
            max-width: 300px; /* Make it narrower */
            min-width: 250px; /* Prevent it from becoming too small */
            max-height: 600px; /* Make it taller */
            min-height: 350px; /* Ensure it has a decent height */
            color: #e2e8f0;
            text-align: center;
            resize: both; /* Allows resizing the window */
            overflow: auto; /* Adds scrollbars if content overflows */
            cursor: grab; /* Indicates it's draggable */
            /* Initial positioning - JavaScript will adjust this */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center it initially */
        }

        .modal-content {
            /* No longer needed as a separate container, its styles are merged into modal-overlay */
            /* Keep this rule to override any lingering default styles if needed, but it won't be a separate draggable element */
        }

        .modal-close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #e2e8f0;
            cursor: pointer;
            padding: 5px;
        }
        .modal-close-button:hover {
            color: #4299e1;
        }

        .modal-content h2 {
            color: #4299e1;
            margin-bottom: 20px;
            font-size: 2em;
        }

        #statsModalHeader {
            cursor: grab; /* Explicitly make the header a grab handle */
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a5568; /* A subtle separator */
            margin-bottom: 20px;
        }

        #profitChartContainer {
            margin-bottom: 20px;
            background-color: #1a202c; /* Chart background */
            padding: 15px;
            border-radius: 8px;
        }

        #betStats {
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        #betStats span {
            font-weight: bold;
            color: #48bb78;
        }

        #resetStatsButton {
            background-color: #e53e3e; /* Red */
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #resetStatsButton:hover {
            background-color: #c53030;
        }

        .hidden {
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: #4a5568;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .controls label {
            font-size: 0.9em;
            color: #cbd5e0;
        }

        .controls input[type="number"],
        .controls select {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e2e8f0;
            font-size: 1em;
            width: 100px; /* Fixed width for inputs/selects */
        }

        .controls button {
            background-color: #38a169; /* Green for start/collect */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .controls button:hover:not(:disabled) {
            background-color: #2f855a;
            transform: translateY(-2px);
        }
        .controls button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .controls button:disabled {
            background-color: #718096;
            cursor: not-allowed;
            box-shadow: none;
        }
        #collectButton {
            background-color: #d69e2e; /* Orange for collect */
        }
        #collectButton:hover:not(:disabled) {
            background-color: #b7791f;
        }

        #mines-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5x5 grid */
            gap: 8px;
            width: 400px; /* Fixed grid width */
            height: 400px; /* Fixed grid height */
            margin: 0 auto 30px auto;
            background-color: #4a5568;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: #636b77; /* Cell color (unclicked) */
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em; /* Base font size for all cells */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s ease;
            user-select: none; /* Prevent text selection */
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Outset shadow for unrevealed */
            
            /* --- Resizing Fix Attempt --- */
            line-height: 0; /* Minimize line height to prevent vertical stretching */
            overflow: hidden; /* Clip content if it tries to expand beyond the cell */
        }

        .cell:hover:not(.revealed):not(.flagged) {
            background-color: #718096; /* Hover effect */
        }

        .cell.revealed {
            background-color: #cbd5e0; /* Revealed cell color */
            cursor: default;
            color: #2d3748;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); 
            transform: none; /* Explicitly ensure no transform */
        }

        .cell.mine {
            background-color: #e53e3e; /* Red for mine */
            color: white;
        }

        .cell.gem {
            background-color: #48bb78; /* Green for safe reveal / gem */
            color: white;
        }

        /* Dev Mode specific styles */
        #devModePasswordSection {
            background-color: #3a414f;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        #devModePasswordSection input {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e2e8f0;
            font-size: 1em;
            width: 180px;
            text-align: center;
        }
        #devModePasswordSection button {
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #devModePasswordSection button:hover {
            background-color: #3182ce;
        }

        #devModeControls {
            background-color: #3a414f;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
        }

        #devModeControls.active {
            display: flex; /* Show when active */
        }

        .dev-control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
        }

        .dev-control-group label {
            color: #cbd5e0;
            font-size: 1em;
        }

        .dev-control-group button {
            padding: 10px 15px;
            font-size: 0.9em;
            background-color: #636b77;
        }
        .dev-control-group button:hover:not(:disabled) {
            background-color: #718096;
        }

        /* Styling for showing mines in dev mode */
        .cell.show-mine {
            background-color: rgba(229, 62, 62, 0.5); /* Semi-transparent red for shown mines */
            border: 2px solid #e53e3e;
        }

        /* Styling for edit mines mode */
        .cell.dev-mine-indicator {
            background-color: rgba(255, 204, 0, 0.4); /* Yellowish highlight */
            border: 2px solid #ffcc00;
        }

        /* Styling for autobet selected squares */
        .cell.autobet-selected {
            background-color: rgba(66, 153, 225, 0.4); /* Blueish highlight */
            border: 2px solid #4299e1;
        }

        #autobetStatus {
            font-size: 1em;
            color: #a0aec0;
            margin-top: -10px;
            margin-bottom: 10px;
        }

        .message {
            font-size: 1.5em;
            font-weight: bold;
            min-height: 1.8em;
            margin-bottom: 20px;
        }
        .message.win { color: #48bb78; }
        .message.lose { color: #e53e3e; }

        .game-state-info {
            font-size: 1.1em;
            margin-top: 15px;
            color: #cbd5e0;
        }
        .game-state-info span {
            font-weight: bold;
            color: #4299e1;
        }
    </style>
</head>
<body>
    <div class="coin-display" onclick="window.location.href='Buy_coins.html'">
        Coins: <span id="coinCount"></span>
    </div>

    <button id="liveStatsButton">Live Stats</button>

    <div class="game-container">
        <h1>Mines</h1>

        <div class="controls">
            <div class="control-group">
                <label for="betAmount">Bet Amount:</label>
                <input type="number" id="betAmount" value="100" min="1" step="0.1"> </div>
            <div class="control-group">
                <label for="minesCount">Mines:</label>
                <select id="minesCount">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10" selected>10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                </select>
            </div>
            <button id="startGameButton">Start Game</button>
            <button id="collectButton" disabled>Collect Winnings</button>
        </div>

        <div id="mines-grid">
            </div>

        <p id="message" class="message"></p>
        <p class="game-state-info">Current Multiplier: <span id="multiplier">1.00x</span></p>
        <p class="game-state-info">Potential Winnings: <span id="potentialWinnings">0</span> Coins</p>

        <div id="devModePasswordSection">
            <input type="password" id="devModePasswordInput" placeholder="Dev Mode Password">
            <button id="unlockDevModeButton">Unlock Dev Mode</button>
            <p id="devPasswordMessage" style="color: #e53e3e; font-size: 0.9em;"></p>
        </div>

        <div id="devModeControls">
            <h3>Dev Controls</h3>
            <div class="dev-control-group">
                <button id="giveCoinsButton">Give 1000 Coins 💰</button>
                <label for="setCoinsInput">Set Coins To:</label>
                <input type="number" id="setCoinsInput" value="1000" min="0" step="0.1"> <button id="setCoinsButton">Set Coins</button>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="showMinesToggle">
                <label for="showMinesToggle">Show Mines</label>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="editMinesToggle">
                <label for="editMinesToggle">Edit Mines</label>
            </div>
            <div class="dev-control-group">
                <button id="easyModeButton">Set Next Game to 1 Mine</button>
                <button id="instantRevealAllButton">Instant Reveal All</button>
                <button id="instantBetButton" style="background-color: #38a169;">Instant Bet</button> </div>
            <div class="dev-control-group">
                <button id="forceWinButton" style="background-color: #48bb78;">Force Win</button>
                <button id="forceLoseButton" style="background-color: #e53e3e;">Force Lose</button>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="luckyMineToggle">
                <label for="luckyMineToggle">Lucky Mine (Autobet 10%)</label>
            </div>
            <hr style="border-color: #4a5568; margin: 10px 0;">
            <h3>Autobet Controls</h3>
            <div class="dev-control-group">
                <input type="checkbox" id="autobetToggle">
                <label for="autobetToggle">Enable Autobet</label>
            </div>
            <div class="dev-control-group">
                <button id="selectAutobetSquaresButton">Select Squares for Autobet</button>
                <button id="clearAutobetSelectionButton">Clear Selection</button>
            </div>
            <p id="autobetStatus">Selected: <span id="selectedAutobetCount">0</span> squares</p>
            <div class="dev-control-group">
                <button id="startAutobetButton">Start Autobet</button>
                <button id="stopAutobetButton" style="background-color: #e53e3e;">Stop Autobet</button>
            </div>
        </div>
    </div>

    <div id="statsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" id="closeStatsModalButton">&times;</button>
            <h2 id="statsModalHeader">Live Stats</h2>
            <div id="profitChartContainer">
                <canvas id="profitChart"></canvas>
            </div>
            <p id="betStats">Total Bets: <span id="totalBetsDisplay">0</span></p>
            <button id="resetStatsButton">Reset Stats</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 5; // 5x5 grid
        const DEV_PASSWORD = "DevMode"; // The password for dev mode
        const AUTOBET_CLICK_DELAY = 300; // ms delay between each autobet click
        const AUTOBET_ROUND_DELAY = 1000; // ms delay before starting next autobet round

        // Initialize coins by parsing as float, then rounding to 1 decimal place
        let coins = parseFloat(localStorage.getItem('coins') || '1000.0'); // Ensure initial value is float
        coins = parseFloat(coins.toFixed(1)); // Round to 1 decimal place and convert back to float

        let betAmount = 0;
        let minesCount = 0;
        let grid = []; // Stores the state of each cell (mine, revealed)
        let minePositions = new Set(); // Stores actual mine positions for the current game
        let customMinePositions = new Set(); // Stores user-edited mine positions for next game
        let revealedGems = 0;
        let gameOver = true;
        let currentMultiplier = 1.00;
        let potentialWinnings = 0;
        let devMode = false;
        let showMinesActive = false;
        let editMinesActive = false;
        let autobetEnabled = false; // New flag for autobet overall
        let selectingAutobetSquares = false; // New flag for selecting squares
        let selectedAutobetSquares = new Set(); // Stores indices for autobet
        let autobetRunning = false; // Flag to control autobet loop
        let autobetTimeoutId = null; // To store timeout for stopping autobet
        let autobetStopping = false; // NEW: Flag to signal an immediate stop of autobet
        let luckyMineForAutobetActive = false; // NEW: Flag for the "lucky mine" feature

        const minesGridEl = document.getElementById('mines-grid');
        const betAmountInput = document.getElementById('betAmount');
        const minesCountSelect = document.getElementById('minesCount');
        const startGameButton = document.getElementById('startGameButton');
        const collectButton = document.getElementById('collectButton');
        const messageEl = document.getElementById('message');
        const coinCountDisplay = document.getElementById('coinCount');
        const multiplierDisplay = document.getElementById('multiplier');
        const potentialWinningsDisplay = document.getElementById('potentialWinnings');

        // Dev Mode Elements
        const devModePasswordSection = document.getElementById('devModePasswordSection');
        const devModePasswordInput = document.getElementById('devModePasswordInput');
        const unlockDevModeButton = document.getElementById('unlockDevModeButton');
        const devPasswordMessage = document.getElementById('devPasswordMessage');
        const devModeControls = document.getElementById('devModeControls');
        const giveCoinsButton = document.getElementById('giveCoinsButton');
        const setCoinsInput = document.getElementById('setCoinsInput'); // New
        const setCoinsButton = document.getElementById('setCoinsButton'); // New
        const showMinesToggle = document.getElementById('showMinesToggle');
        const editMinesToggle = document.getElementById('editMinesToggle');
        const easyModeButton = document.getElementById('easyModeButton');
        const instantRevealAllButton = document.getElementById('instantRevealAllButton'); // New
        const instantBetButton = document.getElementById('instantBetButton'); // NEW: Instant Bet Button
        const forceWinButton = document.getElementById('forceWinButton'); // New
        const forceLoseButton = document.getElementById('forceLoseButton'); // New
        const luckyMineToggle = document.getElementById('luckyMineToggle'); // NEW: Lucky Mine Toggle

        // Autobet Elements
        const autobetToggle = document.getElementById('autobetToggle');
        const selectAutobetSquaresButton = document.getElementById('selectAutobetSquaresButton');
        const clearAutobetSelectionButton = document.getElementById('clearAutobetSelectionButton');
        const selectedAutobetCount = document.getElementById('selectedAutobetCount');
        const startAutobetButton = document.getElementById('startAutobetButton');
        const stopAutobetButton = document.getElementById('stopAutobetButton');

        // New elements for stats
        const liveStatsButton = document.getElementById('liveStatsButton');
        const statsModal = document.getElementById('statsModal');
        const closeStatsModalButton = document.getElementById('closeStatsModalButton');
        const profitChartCanvas = document.getElementById('profitChart');
        const totalBetsDisplay = document.getElementById('totalBetsDisplay');
        const resetStatsButton = document.getElementById('resetStatsButton');
        const statsModalHeader = document.getElementById('statsModalHeader');

        let profitHistory = JSON.parse(localStorage.getItem('profitHistory')) || [0]; // Store profit after each game
        // Ensure profitHistory values are floats and rounded
        profitHistory = profitHistory.map(p => parseFloat(p.toFixed(1)));

        let totalBets = parseInt(localStorage.getItem('totalBets')) || 0;
        let profitChart; // Chart.js instance (renamed from myChart)


        function calculateMultiplier(bombs, gemsFound) {
            if (gemsFound === 0) return 1.00;
            const totalCells = GRID_SIZE * GRID_SIZE;
            const safeCells = totalCells - bombs;
            let multiplier = 1 + (gemsFound * (gemsFound / safeCells) * (bombs / totalCells) * 10);
            if (multiplier < 1) multiplier = 1;
            return multiplier;
        }

        function updateCoinDisplay() {
            coinCountDisplay.textContent = coins.toFixed(1); // Display with one decimal place
            localStorage.setItem('coins', coins.toFixed(1)); // Save with one decimal place
        }

        window.addCoins = function(amount) {
            amount = parseFloat(amount); // Ensure amount is a float
            if (!isNaN(amount) && amount > 0) {
                coins = parseFloat((coins + amount).toFixed(1)); // Add and round
                updateCoinDisplay();
                console.log(`Added ${amount.toFixed(1)} coins. New balance: ${coins.toFixed(1)}`); // Display with 1 decimal
                messageEl.textContent = `+${amount.toFixed(1)} coins via console! 🥳`; // Display with 1 decimal
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            } else {
                console.warn("Invalid amount. Please provide a positive number.");
                messageEl.textContent = "Invalid amount for addCoins. 🤨";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
            }
        };

        // New: Set exact coin amount
        function setCoinsTo() {
            const amount = parseFloat(setCoinsInput.value); // Ensure amount is a float
            if (!isNaN(amount) && amount >= 0) {
                coins = parseFloat(amount.toFixed(1)); // Set and round
                updateCoinDisplay();
                messageEl.textContent = `Coins set to ${amount.toFixed(1)}. 💸`; // Display with 1 decimal
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            } else {
                messageEl.textContent = "Invalid amount for setting coins. 🤔";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
            }
        }

        function generateGrid() {
            minesGridEl.innerHTML = '';
            grid = [];
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                minesGridEl.appendChild(cell);
                grid.push({ hasMine: false, revealed: false });
                // Re-apply autobet selection visual if in selection mode
                // This is specifically for when the grid is regenerated while selection mode is active
                if (selectingAutobetSquares && selectedAutobetSquares.has(i)) {
                    cell.classList.add('autobet-selected');
                }
                // Re-apply dev mine indicator if in edit mode
                if (editMinesActive && customMinePositions.has(i)) {
                    cell.classList.add('dev-mine-indicator');
                }
            }
            // Ensure correct event listener is active based on mode
            enableGameControls(true); // Manages button states
            updateGridEventListeners(); // Manages grid listeners
        }

        function placeMines() {
            minePositions.clear();
            let actualMinesCount = minesCount;

            if (devMode && easyModeButton.dataset.active === 'true') {
                actualMinesCount = 1;
                messageEl.textContent = "Easy Mode: Only 1 mine this game! 😎";
                messageEl.classList.add('win');
            } else if (customMinePositions.size > 0) {
                minePositions = new Set(customMinePositions);
                actualMinesCount = minePositions.size;
                messageEl.textContent = `Using ${actualMinesCount} custom mines! 🛠️`;
                messageEl.classList.add('win');
            }

            // NEW: Lucky mine placement for autobet
            let placedLuckyMine = false;
            if (devMode && luckyMineForAutobetActive && autobetEnabled && selectedAutobetSquares.size > 0 && actualMinesCount > 0) {
                if (Math.random() < 0.10) { // 10% chance
                    const selectedSquaresArray = Array.from(selectedAutobetSquares);
                    const luckyMineIndex = selectedSquaresArray[Math.floor(Math.random() * selectedSquaresArray.length)];
                    minePositions.add(luckyMineIndex);
                    placedLuckyMine = true;
                    console.log(`Lucky mine placed at ${luckyMineIndex} for autobet!`);
                    messageEl.textContent = "A mine was conveniently placed in your autobet path! 😈";
                    messageEl.classList.remove('win');
                    messageEl.classList.add('lose');
                }
            }
            // END NEW

            while (minePositions.size < actualMinesCount) {
                const randomIndex = Math.floor(Math.random() * (GRID_SIZE * GRID_SIZE));
                if (!minePositions.has(randomIndex)) {
                    minePositions.add(randomIndex);
                }
            }

            minePositions.forEach(index => {
                grid[index].hasMine = true;
            });
        }

        function enableGameControls(enable) {
            // Controls for general game buttons and inputs
            startGameButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            betAmountInput.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            minesCountSelect.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            collectButton.disabled = !enable || gameOver || revealedGems === 0 || autobetRunning || selectingAutobetSquares || editMinesActive;

            if (devMode) {
                giveCoinsButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                setCoinsInput.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                setCoinsButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                showMinesToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                editMinesToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || !gameOver; // Can't edit if game running
                easyModeButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                instantRevealAllButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                instantBetButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive || !gameOver; // NEW: Instant Bet button disabled if game is running or in special modes
                forceWinButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                forceLoseButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                luckyMineToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive; // NEW: Lucky Mine Toggle
                autobetToggle.disabled = !enable || editMinesActive; // Can't enable autobet if editing mines
                // selectAutobetSquaresButton should only be disabled if autobet is not enabled OR conditions prevent entering mode
                selectAutobetSquaresButton.disabled = !autobetEnabled || !enable || autobetRunning || editMinesActive || !gameOver;
                clearAutobetSelectionButton.disabled = !autobetEnabled || selectedAutobetSquares.size === 0 || autobetRunning || editMinesActive || !gameOver;
                // FIX (from previous turn): Removed !gameOver from startAutobetButton.disabled condition
                startAutobetButton.disabled = !autobetEnabled || selectedAutobetSquares.size === 0 || autobetRunning || editMinesActive;
                stopAutobetButton.disabled = !autobetRunning;
            }
        }

        // New function to manage grid event listeners
        function updateGridEventListeners() {
            minesGridEl.removeEventListener('click', handleCellClick);
            minesGridEl.removeEventListener('click', handleEditMineClick);
            minesGridEl.removeEventListener('click', handleAutobetSelectionClick);

            if (editMinesActive) {
                minesGridEl.addEventListener('click', handleEditMineClick);
            } else if (selectingAutobetSquares) {
                minesGridEl.addEventListener('click', handleAutobetSelectionClick);
            } else if (!gameOver && !autobetRunning) { // Game is active, no special modes
                minesGridEl.addEventListener('click', handleCellClick);
            }
            // If gameOver and not in edit/autobet select mode, no grid listener is needed
        }

        function startGame() {
            if (coins < parseFloat(betAmountInput.value)) { // Compare float with float
                messageEl.textContent = "Not enough coins for this bet! 😥";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                return false; // Indicate game did not start
            }
            if (autobetEnabled && selectedAutobetSquares.size === 0) {
                messageEl.textContent = "Autobet enabled, but no squares selected! Please select squares or disable autobet. 🤔";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                return false; // Indicate game did not start
            }

            betAmount = parseFloat(betAmountInput.value); // Parse as float
            minesCount = parseInt(minesCountSelect.value);
            coins = parseFloat((coins - betAmount).toFixed(1)); // Subtract bet and round
            updateCoinDisplay();
            totalBets++; // Increment total bets
            saveStats(); // Save stats after bet
            updateStatsDisplay(); // Update stats display

            revealedGems = 0;
            currentMultiplier = 1.00;
            potentialWinnings = 0;
            gameOver = false;
            messageEl.textContent = "Game started! Good luck! ✨";
            messageEl.classList.remove('lose', 'win');

            generateGrid();
            placeMines();
            updateDisplays();
            enableGameControls(false); // Disable game start controls
            collectButton.disabled = true; // Collect button disabled at start

            if (devMode && showMinesToggle.checked) {
                showMines();
            }
            updateGridEventListeners(); // Ensure proper listener after game start
            return true; // Indicate game started successfully
        }

        function revealSquare(index) {
            if (gameOver || grid[index].revealed) return;

            const cell = minesGridEl.children[index];
            grid[index].revealed = true;

            if (grid[index].hasMine) {
                cell.classList.add('mine');
                cell.textContent = '💣';
                gameOver = true;
                messageEl.textContent = `BOOM! You hit a mine. You lost ${betAmount.toFixed(1)} coins. 😭`; // Display with 1 decimal
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                revealAllMines();
                profitHistory.push(parseFloat((profitHistory[profitHistory.length - 1] - betAmount).toFixed(1))); // Subtract bet amount and round
                saveStats();
                updateStatsDisplay();
                enableGameControls(true); // Re-enable start game buttons
                updateGridEventListeners(); // Remove click listener from grid
                // Removed stopAutobet(); call here to allow autobet to continue after a loss
            } else {
                cell.classList.add('gem');
                cell.textContent = '💎';
                revealedGems++;
                currentMultiplier = calculateMultiplier(minesCount, revealedGems);
                potentialWinnings = parseFloat((betAmount * currentMultiplier).toFixed(1)); // Calculate and round
                messageEl.textContent = `Gem found! Current Multiplier: ${currentMultiplier.toFixed(2)}x. Potential Winnings: ${potentialWinnings.toFixed(1)} Coins.`; // Display with 1 decimal
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
                updateDisplays();
                collectButton.disabled = false; // Enable collect button

                // Check if all safe cells are revealed
                const totalCells = GRID_SIZE * GRID_SIZE;
                const safeCells = totalCells - minesCount;
                if (revealedGems === safeCells) {
                    collectWinnings(); // Automatically collect if all safe cells are found
                    messageEl.textContent = `All gems found! You won ${potentialWinnings.toFixed(1)} coins! 🎉`; // Display with 1 decimal
                }
            }
        }

        function collectWinnings() {
            if (gameOver || revealedGems === 0) return;

            coins = parseFloat((coins + potentialWinnings).toFixed(1)); // Add and round
            updateCoinDisplay();
            messageEl.textContent = `You collected ${potentialWinnings.toFixed(1)} coins! 🤑`; // Display with 1 decimal
            messageEl.classList.remove('lose');
            messageEl.classList.add('win');
            gameOver = true;
            profitHistory.push(parseFloat((profitHistory[profitHistory.length - 1] + potentialWinnings - betAmount).toFixed(1))); // Add net profit and round
            saveStats();
            updateStatsDisplay();
            revealAllMines(); // Show remaining mines if any
            enableGameControls(true); // Re-enable start game buttons
            updateGridEventListeners(); // Remove click listener from grid
            // Removed stopAutobet(); call here to allow autobet to continue after collecting
        }

        function updateDisplays() {
            multiplierDisplay.textContent = currentMultiplier.toFixed(2) + 'x';
            potentialWinningsDisplay.textContent = potentialWinnings.toFixed(1); // Display with one decimal place
        }

        function revealAllMines() {
            minesGridEl.querySelectorAll('.cell').forEach((cellEl, index) => {
                const cell = grid[index];
                if (cell.hasMine && !cell.revealed) {
                    cellEl.classList.add('mine');
                    cellEl.textContent = '💣';
                }
            });
        }

        function handleCellClick(event) {
            const cellEl = event.target.closest('.cell');
            if (cellEl) {
                const index = parseInt(cellEl.dataset.index);
                revealSquare(index);
            }
        }

        function toggleDevMode() {
            devMode = !devMode;
            devModePasswordSection.style.display = devMode ? 'none' : 'flex';
            devModeControls.classList.toggle('active', devMode);
            devPasswordMessage.textContent = ''; // Clear message
            enableGameControls(true); // Update button states
        }

        // Dev Mode Functions
        giveCoinsButton.addEventListener('click', () => {
            window.addCoins(1000);
        });

        setCoinsButton.addEventListener('click', setCoinsTo); // Use the new setCoinsTo function

        showMinesToggle.addEventListener('change', () => {
            showMinesActive = showMinesToggle.checked;
            minesGridEl.querySelectorAll('.cell').forEach((cellEl, index) => {
                if (grid[index].hasMine) {
                    cellEl.classList.toggle('show-mine', showMinesActive);
                }
            });
        });

        editMinesToggle.addEventListener('change', () => {
            editMinesActive = editMinesToggle.checked;
            if (editMinesActive) {
                messageEl.textContent = "Edit Mines Mode: Click cells to toggle mine positions for the NEXT game. 🚧";
                messageEl.classList.remove('win', 'lose');
                minesGridEl.querySelectorAll('.cell').forEach((cellEl, index) => {
                    if (customMinePositions.has(index)) {
                        cellEl.classList.add('dev-mine-indicator');
                    }
                });
            } else {
                messageEl.textContent = "Edit Mines Mode Off.";
                minesGridEl.querySelectorAll('.cell').forEach(cellEl => {
                    cellEl.classList.remove('dev-mine-indicator');
                });
            }
            updateGridEventListeners(); // Re-assign click listener based on mode
            enableGameControls(true); // Update button states
        });

        function handleEditMineClick(event) {
            const cellEl = event.target.closest('.cell');
            if (cellEl && editMinesActive) {
                const index = parseInt(cellEl.dataset.index);
                if (customMinePositions.has(index)) {
                    customMinePositions.delete(index);
                    cellEl.classList.remove('dev-mine-indicator');
                } else {
                    customMinePositions.add(index);
                    cellEl.classList.add('dev-mine-indicator');
                }
                messageEl.textContent = `Custom mines set: ${customMinePositions.size}.`;
                messageEl.classList.remove('win', 'lose');
            }
        }

        easyModeButton.addEventListener('click', () => {
            easyModeButton.dataset.active = easyModeButton.dataset.active === 'true' ? 'false' : 'true';
            if (easyModeButton.dataset.active === 'true') {
                messageEl.textContent = "Easy Mode will set next game to 1 mine! ✨";
                messageEl.classList.add('win');
            } else {
                messageEl.textContent = "Easy Mode deactivated.";
                messageEl.classList.remove('win', 'lose');
            }
        });

        instantRevealAllButton.addEventListener('click', instantRevealAll); // New event listener for instant reveal

        function instantRevealAll() {
            if (gameOver || !devMode) return;
            minesGridEl.querySelectorAll('.cell').forEach((cellEl, index) => {
                if (!grid[index].revealed) {
                    revealSquare(index);
                }
            });
        }

        // NEW: Instant Bet function
        function instantBet() {
            if (!devMode) {
                messageEl.textContent = "Instant Bet is a Dev Mode feature. 🤫";
                messageEl.classList.add('lose');
                return;
            }
            if (!gameOver) {
                messageEl.textContent = "A game is already in progress! Finish or collect first. 🛑";
                messageEl.classList.add('lose');
                return;
            }
            if (selectedAutobetSquares.size === 0) { // New check
                messageEl.textContent = "Please select squares for Instant Bet in Autobet Controls! 🤔";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                return;
            }

            // Attempt to start game
            const gameStarted = startGame();
            if (gameStarted) {
                // If game started successfully, instantly reveal selected squares
                const squaresToReveal = Array.from(selectedAutobetSquares);
                for (const index of squaresToReveal) {
                    if (gameOver) { // Check if a mine was hit during revealing selected squares
                        messageEl.textContent = `Instant Bet: Hit a mine on selected square ${index}! You lost. 😭`;
                        messageEl.classList.remove('win');
                        messageEl.classList.add('lose');
                        return; // Stop and exit if a mine is hit
                    }
                    revealSquare(index);
                }

                if (!gameOver) { // If no mine was hit among selected squares, collect winnings
                    collectWinnings();
                    messageEl.textContent = "Instant Bet: Selected squares revealed and winnings collected! �";
                    messageEl.classList.remove('lose');
                    messageEl.classList.add('win');
                } else {
                    // This case is already handled inside the loop if a mine is hit
                }
            } else {
                // startGame already sets a message if it fails (e.g., not enough coins)
                console.log("Instant Bet failed to start game.");
            }
        }

        forceWinButton.addEventListener('click', forceWin); // New
        forceLoseButton.addEventListener('click', forceLose); // New

        function forceWin() {
            if (gameOver || !devMode) return;
            messageEl.textContent = "Forcing a win! 🏆";
            messageEl.classList.remove('lose');
            messageEl.classList.add('win');

            // Find all safe cells and reveal them
            minesGridEl.querySelectorAll('.cell').forEach((cellEl, index) => {
                if (!grid[index].hasMine && !grid[index].revealed) {
                    revealSquare(index);
                }
            });
            collectWinnings(); // Collect winnings after revealing all gems
        }

        function forceLose() {
            if (gameOver || !devMode) return;
            messageEl.textContent = "Forcing a loss! 💀";
            messageEl.classList.remove('win');
            messageEl.classList.add('lose');

            // Find a mine and reveal it
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].hasMine && !grid[i].revealed) {
                    revealSquare(i); // This will end the game
                    return;
                }
            }
            // Fallback: if no mines left (e.g., all collected), just lose the bet
            if (!gameOver) {
                coins = parseFloat((coins - betAmount).toFixed(1)); // Subtract bet and round
                updateCoinDisplay();
                profitHistory.push(parseFloat((profitHistory[profitHistory.length - 1] - betAmount).toFixed(1)));
                saveStats();
                updateStatsDisplay();
                gameOver = true;
                enableGameControls(true);
                updateGridEventListeners();
            }
        }

        // Autobet Functionality
        function toggleAutobetEnabled() {
            autobetEnabled = autobetToggle.checked;
            if (autobetEnabled) {
                messageEl.textContent = "Autobet enabled. Select squares to begin!";
                messageEl.classList.remove('lose', 'win');
            } else {
                stopAutobet(); // Ensure autobet stops if disabled
                messageEl.textContent = "Autobet disabled.";
                messageEl.classList.remove('lose', 'win');
                selectingAutobetSquares = false; // Exit selection mode
                minesGridEl.querySelectorAll('.cell.autobet-selected').forEach(cellEl => {
                    cellEl.classList.remove('autobet-selected');
                });
                enableGameControls(true); // Re-enable controls if autobet was the only thing disabling them
                updateGridEventListeners();
            }
            enableGameControls(true); // Update button states
        }

        function autobetToggleSelectionMode(enable) {
            selectingAutobetSquares = enable;
            if (selectingAutobetSquares) {
                messageEl.textContent = "Click squares to select/deselect for autobet. Click 'Select Squares' again to finish. ✨";
                messageEl.classList.remove('win', 'lose');
                selectAutobetSquaresButton.textContent = "Finish Selecting Squares";
            } else {
                messageEl.textContent = `Selected ${selectedAutobetSquares.size} squares for autobet.`;
                selectAutobetSquaresButton.textContent = "Select Squares for Autobet";
            }
            updateGridEventListeners(); // Change grid listener
            enableGameControls(true); // Update button states
        }

        function handleAutobetSelectionClick(event) {
            const cellEl = event.target.closest('.cell');
            if (cellEl) {
                const index = parseInt(cellEl.dataset.index);
                if (selectedAutobetSquares.has(index)) {
                    selectedAutobetSquares.delete(index);
                    cellEl.classList.remove('autobet-selected');
                } else {
                    selectedAutobetSquares.add(index);
                    cellEl.classList.add('autobet-selected');
                }
                selectedAutobetCount.textContent = selectedAutobetSquares.size;
            }
        }

        function clearAutobetSelection() {
            selectedAutobetSquares.clear();
            minesGridEl.querySelectorAll('.cell.autobet-selected').forEach(cellEl => {
                cellEl.classList.remove('autobet-selected');
            });
            selectedAutobetCount.textContent = 0;
            messageEl.textContent = "Autobet selection cleared. 🧹";
            messageEl.classList.remove('win', 'lose');
            enableGameControls(true);
        }

        async function startAutobet() {
            if (autobetRunning) return;
            if (!autobetEnabled) {
                messageEl.textContent = "Autobet is not enabled!";
                return;
            }
            if (selectedAutobetSquares.size === 0) {
                messageEl.textContent = "No squares selected for autobet!";
                return;
            }
            if (coins < parseFloat(betAmountInput.value)) { // Compare float with float
                messageEl.textContent = "Not enough coins to start autobet! 😥";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                enableGameControls(true); // Re-enable controls if autobet cannot start
                return;
            }

            autobetRunning = true;
            autobetStopping = false; // Reset stopping flag
            messageEl.textContent = "Autobet started! 🤖";
            messageEl.classList.remove('lose', 'win');
            enableGameControls(false); // Disable all controls except stop

            const squaresToClick = Array.from(selectedAutobetSquares);

            while (autobetRunning && !autobetStopping) {
                const gameStarted = startGame(); // Check if game started successfully
                if (!gameStarted) { // If startGame failed (e.g., not enough coins)
                    autobetRunning = false;
                    messageEl.textContent = "Autobet stopped due to insufficient funds! 😔";
                    messageEl.classList.add('lose');
                    enableGameControls(true);
                    return;
                }

                // Click selected squares
                for (let i = 0; i < squaresToClick.length; i++) {
                    const index = squaresToClick[i];
                    if (autobetStopping) break; // Check stop flag
                    const cell = minesGridEl.children[index];
                    if (cell && !grid[index].revealed) { // Only click if not already revealed
                        revealSquare(index);
                        await new Promise(resolve => setTimeout(resolve, AUTOBET_CLICK_DELAY)); // Delay between clicks
                    }
                    if (gameOver) {
                        // If a mine is hit, the game is over, but autobet should continue to the next round.
                        // No need to break the outer loop or call stopAutobet here.
                        break; 
                    }
                }

                if (!gameOver) { // If game is still active (no mine hit), collect winnings
                    collectWinnings();
                }

                await new Promise(resolve => setTimeout(resolve, AUTOBET_ROUND_DELAY)); // Delay before next round
            }
            autobetRunning = false; // Ensure flag is false when loop exits naturally
            messageEl.textContent = "Autobet stopped. 🛑";
            messageEl.classList.remove('win');
            messageEl.classList.add('lose');
            enableGameControls(true); // Re-enable controls
            updateGridEventListeners();
        }

        function stopAutobet() {
            autobetStopping = true; // Signal to stop
            if (autobetTimeoutId) {
                clearTimeout(autobetTimeoutId);
                autobetTimeoutId = null;
            }
            // The loop will eventually check autobetStopping and exit
            messageEl.textContent = "Stopping autobet... Please wait. ⏳";
            messageEl.classList.remove('win', 'lose');
            enableGameControls(false); // Keep controls disabled until fully stopped
        }

        // Live Stats Modal
        liveStatsButton.addEventListener('click', () => {
            statsModal.classList.remove('hidden');
            renderProfitChart(); // Render chart when modal is opened
            updateStatsDisplay(); // Update stats when modal is opened
        });

        closeStatsModalButton.addEventListener('click', () => {
            statsModal.classList.add('hidden');
        });

        resetStatsButton.addEventListener('click', () => {
            profitHistory = [0];
            totalBets = 0;
            saveStats();
            updateStatsDisplay();
            renderProfitChart();
            messageEl.textContent = "Stats reset! 📊";
            messageEl.classList.remove('win', 'lose');
        });

        function saveStats() {
            localStorage.setItem('profitHistory', JSON.stringify(profitHistory));
            localStorage.setItem('totalBets', totalBets);
        }

        function loadStats() {
            profitHistory = JSON.parse(localStorage.getItem('profitHistory')) || [0];
            // Ensure profitHistory values are floats and rounded when loaded
            profitHistory = profitHistory.map(p => parseFloat(p.toFixed(1)));
            totalBets = parseInt(localStorage.getItem('totalBets')) || 0;
        }

        function updateStatsDisplay() {
            totalBetsDisplay.textContent = totalBets;
            if (profitChart) {
                renderProfitChart(); // Re-render chart to reflect new data
            }
        }

        function renderProfitChart() {
            if (profitChart) {
                profitChart.destroy(); // Destroy existing chart before creating a new one
            }

            const ctx = profitChartCanvas.getContext('2d');
            profitChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: profitHistory.map((_, i) => ''), // Empty labels for cleaner look
                    datasets: [{
                        label: 'Profit/Loss', // Simpler label
                        data: profitHistory,
                        borderColor: '#4299e1', // Default blue for the line (will be overridden by segments)
                        backgroundColor: (context) => {
                            // Default background, will be overridden by segment for specific parts
                            const gradient = ctx.createLinearGradient(0, 0, 0, profitChartCanvas.height);
                            gradient.addColorStop(0, 'rgba(66, 153, 225, 0.4)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                            return gradient;
                        },
                        tension: 0.4, // Slightly smoother line
                        fill: true,
                        pointRadius: 0, // Hide data points
                        borderWidth: 2, // Thicker line
                        segment: { // Apply segment-specific styling
                            borderColor: (ctx) => {
                                const y0 = ctx.p0.parsed.y;
                                const y1 = ctx.p1.parsed.y;
                                // If both points are above or on zero, or crossing from negative to positive
                                if ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 >= 0)) {
                                    return '#48bb78'; // Green
                                }
                                // If both points are below or on zero, or crossing from positive to negative
                                else if ((y0 <= 0 && y1 <= 0) || (y0 >= 0 && y1 < 0)) {
                                    return '#e53e3e'; // Red
                                }
                                return '#4299e1'; // Fallback for other cases (shouldn't happen with proper logic)
                            },
                            backgroundColor: (ctx) => {
                                const y0 = ctx.p0.parsed.y;
                                const y1 = ctx.p1.parsed.y;
                                const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, ctx.chart.height);

                                // If both points are above or on zero, or crossing from negative to positive
                                if ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 >= 0)) {
                                    gradient.addColorStop(0, 'rgba(72, 187, 120, 0.4)'); // Green fill
                                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                }
                                // If both points are below or on zero, or crossing from positive to negative
                                else if ((y0 <= 0 && y1 <= 0) || (y0 >= 0 && y1 < 0)) {
                                    gradient.addColorStop(0, 'rgba(229, 62, 62, 0.4)'); // Red fill
                                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                } else {
                                    // Fallback for other cases, use a neutral fill
                                    gradient.addColorStop(0, 'rgba(66, 153, 225, 0.4)');
                                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                }
                                return gradient;
                            }
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: false, // Hide x-axis
                            grid: {
                                display: false // Hide x-axis grid lines
                            }
                        },
                        y: {
                            grid: {
                                color: '#4a5568', // Keep subtle y-axis grid lines
                                drawBorder: false // Hide y-axis border
                            },
                            ticks: {
                                color: '#e2e8f0', // Keep y-axis tick color
                                beginAtZero: false // Allow chart to not start at zero
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false // Hide the legend completely for simplicity
                        },
                        tooltip: {
                            enabled: true // Keep tooltips on hover for detail
                        }
                    }
                }
            });
        }

        // Draggable Window Functionality for Stats Modal
        let isDragging = false;
        let offsetX, offsetY;

        statsModalHeader.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Only left click
                isDragging = true;
                statsModal.style.cursor = 'grabbing';
                // Calculate offset relative to the modal's current position
                const rect = statsModal.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                statsModal.style.transition = 'none'; // Disable transition during drag
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            // Calculate new position relative to the viewport
            let newLeft = e.clientX - offsetX;
            let newTop = e.clientY - offsetY;

            // Optional: Boundary checks (e.g., keep within viewport)
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const modalWidth = statsModal.offsetWidth;
            const modalHeight = statsModal.offsetHeight;

            // Prevent dragging outside the left/top edges
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;

            // Prevent dragging outside the right/bottom edges
            if (newLeft + modalWidth > viewportWidth) newLeft = viewportWidth - modalWidth;
            if (newTop + modalHeight > viewportHeight) newTop = viewportHeight - modalHeight;


            // Apply new position
            statsModal.style.left = `${newLeft}px`;
            statsModal.style.top = `${newTop}px`;
            statsModal.style.transform = 'none'; // Remove transform to allow direct top/left positioning
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            statsModal.style.cursor = 'grab';
            statsModal.style.transition = ''; // Re-enable transition after drag
        });

        // Event Listeners for Dev Mode Password
        unlockDevModeButton.addEventListener('click', () => {
            if (devModePasswordInput.value === DEV_PASSWORD) {
                toggleDevMode();
            } else {
                devPasswordMessage.textContent = "Incorrect password.";
            }
        });

        // Dev Mode Toggles
        document.addEventListener('keydown', (e) => {
            if (e.key === 'D' && e.ctrlKey && e.shiftKey) { // Ctrl+Shift+D to toggle dev mode
                if (devMode) {
                    toggleDevMode(); // Turn off if already on
                } else {
                    // Show password section if not in dev mode
                    devModePasswordSection.style.display = 'flex';
                    devPasswordMessage.textContent = 'Enter Dev Mode Password:';
                    devPasswordMessage.style.color = '#cbd5e0';
                    devModePasswordInput.focus();
                }
            }
        });

        // Event Listeners
        startGameButton.addEventListener('click', startGame);
        collectButton.addEventListener('click', collectWinnings);
        minesGridEl.addEventListener('click', handleCellClick); // Initial listener, will be updated by updateGridEventListeners

        // NEW: Instant Bet Button Event Listener
        instantBetButton.addEventListener('click', instantBet);

        // Autobet Event Listeners
        autobetToggle.addEventListener('change', toggleAutobetEnabled);
        selectAutobetSquaresButton.addEventListener('click', () => {
            // Toggle the selection mode
            autobetToggleSelectionMode(!selectingAutobetSquares);
        });
        clearAutobetSelectionButton.addEventListener('click', clearAutobetSelection);
        startAutobetButton.addEventListener('click', startAutobet);
        stopAutobetButton.addEventListener('click', stopAutobet);


        // Initial setup
        updateCoinDisplay();
        loadStats(); // Load stats on page load
        generateGrid();
        updateDisplays();
        enableGameControls(true); // Call to set initial button states
    </script>
</body>
</html>
