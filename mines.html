<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mines Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2d3748; /* Darker grey */
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #4299e1; /* Blue */
            margin-bottom: 25px;
            font-size: 2.5em;
        }

        .coin-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2em;
            background-color: #4a5568; /* Slightly lighter dark grey */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 100; /* Ensure it's on top */
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: #4a5568;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .controls label {
            font-size: 0.9em;
            color: #cbd5e0;
        }

        .controls input[type="number"],
        .controls select {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e2e8f0;
            font-size: 1em;
            width: 100px; /* Fixed width for inputs/selects */
        }

        .controls button {
            background-color: #38a169; /* Green for start/collect */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .controls button:hover:not(:disabled) {
            background-color: #2f855a;
            transform: translateY(-2px);
        }
        .controls button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .controls button:disabled {
            background-color: #718096;
            cursor: not-allowed;
            box-shadow: none;
        }
        #collectButton {
            background-color: #d69e2e; /* Orange for collect */
        }
        #collectButton:hover:not(:disabled) {
            background-color: #b7791f;
        }

        #mines-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5x5 grid */
            gap: 8px;
            width: 400px; /* Fixed grid width */
            height: 400px; /* Fixed grid height */
            margin: 0 auto 30px auto;
            background-color: #4a5568;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: #636b77; /* Cell color (unclicked) */
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em; /* Base font size for all cells */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s ease;
            user-select: none; /* Prevent text selection */
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Outset shadow for unrevealed */
            
            /* --- Resizing Fix Attempt --- */
            line-height: 0; /* Minimize line height to prevent vertical stretching */
            overflow: hidden; /* Clip content if it tries to expand beyond the cell */
        }

        .cell:hover:not(.revealed):not(.flagged) {
            background-color: #718096; /* Hover effect */
        }

        .cell.revealed {
            background-color: #cbd5e0; /* Revealed cell color */
            cursor: default;
            color: #2d3748;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); 
            transform: none; /* Explicitly ensure no transform */
        }

        .cell.mine {
            background-color: #e53e3e; /* Red for mine */
            color: white;
        }

        .cell.gem {
            background-color: #48bb78; /* Green for safe reveal / gem */
            color: white;
        }

        /* Dev Mode specific styles */
        #devModePasswordSection {
            background-color: #3a414f;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        #devModePasswordSection input {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 5px;
            padding: 8px 12px;
            color: #e2e8f0;
            font-size: 1em;
            width: 180px;
            text-align: center;
        }
        #devModePasswordSection button {
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #devModePasswordSection button:hover {
            background-color: #3182ce;
        }

        #devModeControls {
            background-color: #3a414f;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
        }

        #devModeControls.active {
            display: flex; /* Show when active */
        }

        .dev-control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
        }

        .dev-control-group label {
            color: #cbd5e0;
            font-size: 1em;
        }

        .dev-control-group button {
            padding: 10px 15px;
            font-size: 0.9em;
            background-color: #636b77;
        }
        .dev-control-group button:hover:not(:disabled) {
            background-color: #718096;
        }

        /* Styling for showing mines in dev mode */
        .cell.show-mine {
            background-color: rgba(229, 62, 62, 0.5); /* Semi-transparent red for shown mines */
            border: 2px solid #e53e3e;
        }

        /* Styling for edit mines mode */
        .cell.dev-mine-indicator {
            background-color: rgba(255, 204, 0, 0.4); /* Yellowish highlight */
            border: 2px solid #ffcc00;
        }

        /* Styling for autobet selected squares */
        .cell.autobet-selected {
            background-color: rgba(66, 153, 225, 0.4); /* Blueish highlight */
            border: 2px solid #4299e1;
        }

        #autobetStatus {
            font-size: 1em;
            color: #a0aec0;
            margin-top: -10px;
            margin-bottom: 10px;
        }

        .message {
            font-size: 1.5em;
            font-weight: bold;
            min-height: 1.8em;
            margin-bottom: 20px;
        }
        .message.win { color: #48bb78; }
        .message.lose { color: #e53e3e; }

        .game-state-info {
            font-size: 1.1em;
            margin-top: 15px;
            color: #cbd5e0;
        }
        .game-state-info span {
            font-weight: bold;
            color: #4299e1;
        }
    </style>
</head>
<body>
    <div class="coin-display" onclick="window.location.href='Buy_coins.html'">
        Coins: <span id="coinCount"></span>
    </div>

    <div class="game-container">
        <h1>Mines</h1>

        <div class="controls">
            <div class="control-group">
                <label for="betAmount">Bet Amount:</label>
                <input type="number" id="betAmount" value="100" min="1" step="10">
            </div>
            <div class="control-group">
                <label for="minesCount">Mines:</label>
                <select id="minesCount">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10" selected>10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                </select>
            </div>
            <button id="startGameButton">Start Game</button>
            <button id="collectButton" disabled>Collect Winnings</button>
        </div>

        <div id="mines-grid">
            </div>

        <p id="message" class="message"></p>
        <p class="game-state-info">Current Multiplier: <span id="multiplier">1.00x</span></p>
        <p class="game-state-info">Potential Winnings: <span id="potentialWinnings">0</span> Coins</p>

        <div id="devModePasswordSection">
            <input type="password" id="devModePasswordInput" placeholder="Dev Mode Password">
            <button id="unlockDevModeButton">Unlock Dev Mode</button>
            <p id="devPasswordMessage" style="color: #e53e3e; font-size: 0.9em;"></p>
        </div>

        <div id="devModeControls">
            <h3>Dev Controls</h3>
            <div class="dev-control-group">
                <button id="giveCoinsButton">Give 1000 Coins üí∞</button>
                <label for="setCoinsInput">Set Coins To:</label>
                <input type="number" id="setCoinsInput" value="1000" min="0">
                <button id="setCoinsButton">Set Coins</button>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="showMinesToggle">
                <label for="showMinesToggle">Show Mines</label>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="editMinesToggle">
                <label for="editMinesToggle">Edit Mines</label>
            </div>
            <div class="dev-control-group">
                <button id="easyModeButton">Set Next Game to 1 Mine</button>
                <button id="instantRevealAllButton">Instant Reveal All</button>
            </div>
            <div class="dev-control-group">
                <button id="forceWinButton" style="background-color: #48bb78;">Force Win</button>
                <button id="forceLoseButton" style="background-color: #e53e3e;">Force Lose</button>
            </div>
            <div class="dev-control-group">
                <input type="checkbox" id="luckyMineToggle">
                <label for="luckyMineToggle">Lucky Mine (Autobet 10%)</label>
            </div>
            <hr style="border-color: #4a5568; margin: 10px 0;">
            <h3>Autobet Controls</h3>
            <div class="dev-control-group">
                <input type="checkbox" id="autobetToggle">
                <label for="autobetToggle">Enable Autobet</label>
            </div>
            <div class="dev-control-group">
                <button id="selectAutobetSquaresButton">Select Squares for Autobet</button>
                <button id="clearAutobetSelectionButton">Clear Selection</button>
            </div>
            <p id="autobetStatus">Selected: <span id="selectedAutobetCount">0</span> squares</p>
            <div class="dev-control-group">
                <button id="startAutobetButton">Start Autobet</button>
                <button id="stopAutobetButton" style="background-color: #e53e3e;">Stop Autobet</button>
            </div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 5; // 5x5 grid
        const DEV_PASSWORD = "DevMode"; // The password for dev mode
        const AUTOBET_CLICK_DELAY = 300; // ms delay between each autobet click
        const AUTOBET_ROUND_DELAY = 1000; // ms delay before starting next autobet round

        let coins = parseInt(localStorage.getItem('coins') || '1000');
        let betAmount = 0;
        let minesCount = 0;
        let grid = []; // Stores the state of each cell (mine, revealed)
        let minePositions = new Set(); // Stores actual mine positions for the current game
        let customMinePositions = new Set(); // Stores user-edited mine positions for next game
        let revealedGems = 0;
        let gameOver = true;
        let currentMultiplier = 1.00;
        let potentialWinnings = 0;
        let devMode = false;
        let showMinesActive = false;
        let editMinesActive = false;
        let autobetEnabled = false; // New flag for autobet overall
        let selectingAutobetSquares = false; // New flag for selecting squares
        let selectedAutobetSquares = new Set(); // Stores indices for autobet
        let autobetRunning = false; // Flag to control autobet loop
        let autobetTimeoutId = null; // To store timeout for stopping autobet
        let autobetStopping = false; // NEW: Flag to signal an immediate stop of autobet
        let luckyMineForAutobetActive = false; // NEW: Flag for the "lucky mine" feature

        const minesGridEl = document.getElementById('mines-grid');
        const betAmountInput = document.getElementById('betAmount');
        const minesCountSelect = document.getElementById('minesCount');
        const startGameButton = document.getElementById('startGameButton');
        const collectButton = document.getElementById('collectButton');
        const messageEl = document.getElementById('message');
        const coinCountDisplay = document.getElementById('coinCount');
        const multiplierDisplay = document.getElementById('multiplier');
        const potentialWinningsDisplay = document.getElementById('potentialWinnings');

        // Dev Mode Elements
        const devModePasswordSection = document.getElementById('devModePasswordSection');
        const devModePasswordInput = document.getElementById('devModePasswordInput');
        const unlockDevModeButton = document.getElementById('unlockDevModeButton');
        const devPasswordMessage = document.getElementById('devPasswordMessage');
        const devModeControls = document.getElementById('devModeControls');
        const giveCoinsButton = document.getElementById('giveCoinsButton');
        const setCoinsInput = document.getElementById('setCoinsInput'); // New
        const setCoinsButton = document.getElementById('setCoinsButton'); // New
        const showMinesToggle = document.getElementById('showMinesToggle');
        const editMinesToggle = document.getElementById('editMinesToggle');
        const easyModeButton = document.getElementById('easyModeButton');
        const instantRevealAllButton = document.getElementById('instantRevealAllButton'); // New
        const forceWinButton = document.getElementById('forceWinButton'); // New
        const forceLoseButton = document.getElementById('forceLoseButton'); // New
        const luckyMineToggle = document.getElementById('luckyMineToggle'); // NEW: Lucky Mine Toggle

        // Autobet Elements
        const autobetToggle = document.getElementById('autobetToggle');
        const selectAutobetSquaresButton = document.getElementById('selectAutobetSquaresButton');
        const clearAutobetSelectionButton = document.getElementById('clearAutobetSelectionButton');
        const selectedAutobetCount = document.getElementById('selectedAutobetCount');
        const startAutobetButton = document.getElementById('startAutobetButton');
        const stopAutobetButton = document.getElementById('stopAutobetButton');


        function calculateMultiplier(bombs, gemsFound) {
            if (gemsFound === 0) return 1.00;
            const totalCells = GRID_SIZE * GRID_SIZE;
            const safeCells = totalCells - bombs;
            let multiplier = 1 + (gemsFound * (gemsFound / safeCells) * (bombs / totalCells) * 10);
            if (multiplier < 1) multiplier = 1;
            return multiplier;
        }

        function updateCoinDisplay() {
            coinCountDisplay.textContent = coins;
            localStorage.setItem('coins', coins);
        }

        window.addCoins = function(amount) {
            amount = parseInt(amount);
            if (!isNaN(amount) && amount > 0) {
                coins += amount;
                updateCoinDisplay();
                console.log(`Added ${amount} coins. New balance: ${coins}`);
                messageEl.textContent = `+${amount} coins via console! ü•≥`;
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            } else {
                console.warn("Invalid amount. Please provide a positive number.");
                messageEl.textContent = "Invalid amount for addCoins. ü§®";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
            }
        };

        // New: Set exact coin amount
        function setCoinsTo() {
            const amount = parseInt(setCoinsInput.value);
            if (!isNaN(amount) && amount >= 0) {
                coins = amount;
                updateCoinDisplay();
                messageEl.textContent = `Coins set to ${amount}. üí∏`;
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            } else {
                messageEl.textContent = "Invalid amount for setting coins. ü§î";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
            }
        }


        function generateGrid() {
            minesGridEl.innerHTML = '';
            grid = [];
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                minesGridEl.appendChild(cell);
                grid.push({
                    hasMine: false,
                    revealed: false,
                });

                // Re-apply autobet selection visual if in selection mode
                // This is specifically for when the grid is regenerated while selection mode is active
                if (selectingAutobetSquares && selectedAutobetSquares.has(i)) {
                    cell.classList.add('autobet-selected');
                }
                // Re-apply dev mine indicator if in edit mode
                if (editMinesActive && customMinePositions.has(i)) {
                    cell.classList.add('dev-mine-indicator');
                }
            }
            // Ensure correct event listener is active based on mode
            enableGameControls(true); // Manages button states
            updateGridEventListeners(); // Manages grid listeners
        }

        function placeMines() {
            minePositions.clear();
            let actualMinesCount = minesCount;

            if (devMode && easyModeButton.dataset.active === 'true') {
                actualMinesCount = 1;
                messageEl.textContent = "Easy Mode: Only 1 mine this game! üòé";
                messageEl.classList.add('win');
            } else if (customMinePositions.size > 0) {
                minePositions = new Set(customMinePositions);
                actualMinesCount = minePositions.size;
                messageEl.textContent = `Using ${actualMinesCount} custom mines! üõ†Ô∏è`;
                messageEl.classList.add('win');
            }

            // NEW: Lucky mine placement for autobet
            let placedLuckyMine = false;
            if (devMode && luckyMineForAutobetActive && autobetEnabled && selectedAutobetSquares.size > 0 && actualMinesCount > 0) {
                if (Math.random() < 0.10) { // 10% chance
                    const selectedSquaresArray = Array.from(selectedAutobetSquares);
                    const luckyMineIndex = selectedSquaresArray[Math.floor(Math.random() * selectedSquaresArray.length)];
                    minePositions.add(luckyMineIndex);
                    placedLuckyMine = true;
                    console.log(`Lucky mine placed at ${luckyMineIndex} for autobet!`);
                    messageEl.textContent = "A mine was conveniently placed in your autobet path! üòà";
                    messageEl.classList.remove('win');
                    messageEl.classList.add('lose');
                }
            }
            // END NEW

            while (minePositions.size < actualMinesCount) {
                const randomIndex = Math.floor(Math.random() * (GRID_SIZE * GRID_SIZE));
                if (!minePositions.has(randomIndex)) {
                    minePositions.add(randomIndex);
                }
            }

            minePositions.forEach(index => {
                grid[index].hasMine = true;
            });
        }

        function enableGameControls(enable) {
            // Controls for general game buttons and inputs
            startGameButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            betAmountInput.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            minesCountSelect.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
            collectButton.disabled = !enable || gameOver || revealedGems === 0 || autobetRunning || selectingAutobetSquares || editMinesActive;
            
            if (devMode) {
                giveCoinsButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                setCoinsInput.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                setCoinsButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                showMinesToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                editMinesToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || !gameOver; // Can't edit if game running
                easyModeButton.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive;
                instantRevealAllButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                forceWinButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                forceLoseButton.disabled = !enable || gameOver || autobetRunning || selectingAutobetSquares || editMinesActive; // Only if game is active
                luckyMineToggle.disabled = !enable || autobetRunning || selectingAutobetSquares || editMinesActive; // NEW: Lucky Mine Toggle

                autobetToggle.disabled = !enable || editMinesActive; // Can't enable autobet if editing mines
                // selectAutobetSquaresButton should only be disabled if autobet is not enabled OR conditions prevent entering mode
                selectAutobetSquaresButton.disabled = !autobetEnabled || !enable || autobetRunning || editMinesActive || !gameOver;
                clearAutobetSelectionButton.disabled = !autobetEnabled || selectedAutobetSquares.size === 0 || autobetRunning || editMinesActive || !gameOver;
                
                // FIX (from previous turn): Removed !gameOver from startAutobetButton.disabled condition
                startAutobetButton.disabled = !autobetEnabled || selectedAutobetSquares.size === 0 || autobetRunning || editMinesActive;
                
                stopAutobetButton.disabled = !autobetRunning;
            }
        }

        // New function to manage grid event listeners
        function updateGridEventListeners() {
            minesGridEl.removeEventListener('click', handleCellClick);
            minesGridEl.removeEventListener('click', handleEditMineClick);
            minesGridEl.removeEventListener('click', handleAutobetSelectionClick);

            if (editMinesActive) {
                minesGridEl.addEventListener('click', handleEditMineClick);
            } else if (selectingAutobetSquares) {
                minesGridEl.addEventListener('click', handleAutobetSelectionClick);
            } else if (!gameOver && !autobetRunning) { // Game is active, no special modes
                minesGridEl.addEventListener('click', handleCellClick);
            }
            // If gameOver is true (game not started/ended) AND not in edit/autobet selection mode, no click listener is needed.
        }

        function startGame() {
            if (gameOver) {
                if (editMinesActive) {
                    messageEl.textContent = "Exit 'Edit Mines' mode to start game. üõë";
                    messageEl.classList.add('lose');
                    return false;
                }
                if (selectingAutobetSquares) {
                    messageEl.textContent = "Exit 'Autobet Selection' mode to start game. üõë";
                    messageEl.classList.add('lose');
                    return false;
                }

                betAmount = parseInt(betAmountInput.value);
                minesCount = parseInt(minesCountSelect.value);

                if (isNaN(betAmount) || betAmount <= 0) {
                    messageEl.textContent = "Please enter a valid bet amount. üòî";
                    messageEl.classList.add('lose');
                    return false;
                }
                if (betAmount > coins) {
                    messageEl.textContent = "You don't have enough coins for that bet! üí∏";
                    messageEl.classList.add('lose');
                    return false;
                }

                coins -= betAmount;
                updateCoinDisplay();

                gameOver = false;
                revealedGems = 0;
                currentMultiplier = 1.00;
                potentialWinnings = 0;
                messageEl.textContent = '';
                messageEl.className = 'message';

                // Ensure controls are set correctly for game start
                enableGameControls(false); // Disable game setup controls
                updateGridEventListeners(); // Set up grid listeners for game play

                generateGrid(); 
                placeMines();
                updateDisplays();

                if (devMode && showMinesActive) {
                    toggleShowMinesVisual(true);
                }
                return true;
            }
            return false;
        }

        function revealCell(index) {
            if (gameOver || grid[index].revealed) return false;

            const cellEl = minesGridEl.children[index];
            grid[index].revealed = true;
            cellEl.classList.add('revealed');

            if (grid[index].hasMine) {
                cellEl.classList.add('mine');
                cellEl.textContent = 'üí£';
                endGame(false); // Game Over (Loss)
                return false;
            } else {
                cellEl.classList.add('gem');
                cellEl.textContent = 'üíé';
                revealedGems++;
                
                updateDisplays();
                
                if (revealedGems > 0 && !gameOver && !autobetRunning) {
                    collectButton.disabled = false;
                }

                if (revealedGems === (GRID_SIZE * GRID_SIZE) - minePositions.size) {
                    // All safe cells revealed, this is a win for the round
                    // No direct endGame(true) here, collection or autobet will handle.
                }
                return true;
            }
        }

        function handleCellClick(event) {
            if (gameOver) return;
            const index = parseInt(event.target.dataset.index);
            revealCell(index);
        }

        function handleEditMineClick(event) {
            if (!editMinesActive || !gameOver) return; // Only allow editing if not in game

            const cellEl = event.target;
            const index = parseInt(cellEl.dataset.index);

            if (customMinePositions.has(index)) {
                customMinePositions.delete(index);
                cellEl.classList.remove('dev-mine-indicator');
                grid[index].hasMine = false;
            } else {
                customMinePositions.add(index);
                cellEl.classList.add('dev-mine-indicator');
                grid[index].hasMine = true;
            }
            minesCountSelect.value = customMinePositions.size;
        }

        function handleAutobetSelectionClick(event) {
            if (!selectingAutobetSquares || !gameOver) return; // Only allow selection if not in game

            const cellEl = event.target;
            const index = parseInt(cellEl.dataset.index);

            if (selectedAutobetSquares.has(index)) {
                selectedAutobetSquares.delete(index);
                cellEl.classList.remove('autobet-selected');
            } else {
                selectedAutobetSquares.add(index);
                cellEl.classList.add('autobet-selected');
            }
            selectedAutobetCount.textContent = selectedAutobetSquares.size;
            enableGameControls(true); // Re-evaluate button states
        }


        function updateDisplays() {
            currentMultiplier = calculateMultiplier(minePositions.size, revealedGems);
            potentialWinnings = Math.floor(betAmount * currentMultiplier);

            multiplierDisplay.textContent = `${currentMultiplier.toFixed(2)}x`;
            potentialWinningsDisplay.textContent = `${potentialWinnings} Coins`;
        }

        function endGame(win) {
            gameOver = true;
            
            // If autobet is running, don't immediately re-enable controls or stop it here.
            // Let autobetLoop decide the next action (restart or fully stop if autobetRunning becomes false)
            if (!autobetRunning) { 
                enableGameControls(true);
                updateGridEventListeners(); // Update grid listeners after game ends
            }
            // Clear any lingering dev/autobet specific visuals for the cells on game end
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                minesGridEl.children[i].classList.remove('dev-mine-indicator', 'autobet-selected');
            }

            if (showMinesActive) {
                toggleShowMinesVisual(false);
                showMinesToggle.checked = false;
            }
            easyModeButton.dataset.active = 'false';
            easyModeButton.style.backgroundColor = '';

            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cellEl = minesGridEl.children[i];
                if (grid[i].hasMine && !grid[i].revealed) {
                    cellEl.classList.add('revealed', 'mine');
                    cellEl.textContent = 'üí£';
                }
                if (!grid[i].hasMine && !grid[i].revealed) {
                    cellEl.classList.add('revealed', 'gem');
                    cellEl.textContent = 'üíé';
                }
            }

            if (win) {
                messageEl.textContent = 'Congratulations! All gems found! üéâ';
                messageEl.classList.add('win');
            } else {
                messageEl.textContent = 'Boom! You hit a mine. Game Over! üí•';
                messageEl.classList.add('lose');
                potentialWinnings = 0; // Ensure winnings are 0 on loss
                updateDisplays();
            }
            // Clear custom mine positions after game if they were used and edit mode is not active
            if (customMinePositions.size > 0 && !editMinesActive) {
                 customMinePositions.clear();
                 minesCountSelect.value = 10;
                 minesCountSelect.disabled = false;
            }
        }

        function collectWinnings() {
            if (!gameOver && revealedGems > 0) { // Only collect if game is active and gems revealed
                coins += potentialWinnings;
                updateCoinDisplay();
                messageEl.textContent = `You collected ${potentialWinnings} coins! Good job! üí∞`;
                messageEl.classList.add('win');
                
                gameOver = true; // IMPORTANT: Mark game as over after collecting
                
                // Reveal any remaining mines/gems for visual clarity after collection
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cellEl = minesGridEl.children[i];
                    if (grid[i].hasMine && !grid[i].revealed) {
                        cellEl.classList.add('revealed', 'mine');
                        cellEl.textContent = 'üí£';
                    }
                    if (!grid[i].hasMine && !grid[i].revealed) {
                        cellEl.classList.add('revealed', 'gem');
                        cellEl.textContent = 'üíé';
                    }
                    cellEl.classList.remove('dev-mine-indicator');
                    cellEl.classList.remove('autobet-selected');
                }

                if (showMinesActive) {
                    toggleShowMinesVisual(false);
                    showMinesToggle.checked = false;
                }
                easyModeButton.dataset.active = 'false';
                easyModeButton.style.backgroundColor = '';

                // If autobet is running, let autobetLoop handle the next step.
                // Otherwise, re-enable controls for manual play.
                if (!autobetRunning) {
                    enableGameControls(true);
                    updateGridEventListeners();
                } else {
                    // During autobet, clear message to prepare for next round's message
                    // messageEl.textContent = ''; 
                }

            } else if (revealedGems === 0) {
                messageEl.textContent = "You need to reveal at least one gem to collect. ü§î";
                messageEl.classList.add('lose');
            }

            if (customMinePositions.size > 0 && !editMinesActive) {
                 customMinePositions.clear();
                 minesCountSelect.value = 10;
                 minesCountSelect.disabled = false;
            }
        }

        // New Dev Mode Debugging Functions
        function instantRevealAll() {
            if (gameOver) {
                messageEl.textContent = "Start a game first to reveal all! ‚òùÔ∏è";
                messageEl.classList.add('lose');
                return;
            }
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                if (!grid[i].revealed) {
                    grid[i].revealed = true;
                    const cellEl = minesGridEl.children[i];
                    cellEl.classList.add('revealed');
                    if (grid[i].hasMine) {
                        cellEl.classList.add('mine');
                        cellEl.textContent = 'üí£';
                    } else {
                        cellEl.classList.add('gem');
                        cellEl.textContent = 'üíé';
                        revealedGems++; // Count gems for potential win check
                    }
                }
            }
            // Check for win/lose after revealing all
            if (grid.some(cell => cell.hasMine && cell.revealed)) { // If any mine was revealed
                endGame(false);
            } else {
                endGame(true); // All safe cells revealed, or no mines hit
            }
            messageEl.textContent = "All cells instantly revealed! ‚ú®";
            messageEl.classList.add('win');
        }

        function forceWin() {
            if (gameOver) {
                messageEl.textContent = "Start a game first to force a win! ‚òùÔ∏è";
                messageEl.classList.add('lose');
                return;
            }
            // Set revealedGems to max possible safe cells
            revealedGems = (GRID_SIZE * GRID_SIZE) - minePositions.size;
            endGame(true);
            messageEl.textContent = "Forced Win! üéâ";
            messageEl.classList.add('win');
        }

        function forceLose() {
            if (gameOver) {
                messageEl.textContent = "Start a game first to force a lose! ‚òùÔ∏è";
                messageEl.classList.add('lose');
                return;
            }
            // Find a mine and reveal it
            const mineIndex = Array.from(minePositions)[0];
            if (mineIndex !== undefined) {
                grid[mineIndex].revealed = true; // Mark as revealed to trigger loss
                endGame(false);
            } else {
                // If for some reason there are no mines (e.g. 0 mines selected)
                messageEl.textContent = "Cannot force lose, no mines present! üòÖ";
                messageEl.classList.add('lose');
            }
            messageEl.textContent = "Forced Lose! üòµ‚Äçüí´";
            messageEl.classList.add('lose');
        }


        // Dev Mode Logic
        function unlockDevMode() {
            if (devModePasswordInput.value === DEV_PASSWORD) {
                devMode = true;
                devModePasswordSection.style.display = 'none';
                devModeControls.classList.add('active');
                devPasswordMessage.textContent = "Dev Mode Unlocked! üéâ";
                devPasswordMessage.style.color = '#48bb78';
                console.log("Dev Mode ON.");
                enableGameControls(true);
                updateGridEventListeners(); // Update grid listeners for dev mode
            } else {
                devPasswordMessage.textContent = "Incorrect password. üö´";
                devPasswordMessage.style.color = '#e53e3e';
            }
        }

        function toggleShowMinesVisual(enable) {
            showMinesActive = enable;
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cellEl = minesGridEl.children[i];
                if (grid[i].hasMine && !grid[i].revealed) {
                    if (enable) {
                        cellEl.classList.add('show-mine');
                    } else {
                        cellEl.classList.remove('show-mine');
                    }
                }
            }
        }

        function toggleEditMinesMode() {
            editMinesActive = editMinesToggle.checked;
            if (editMinesActive) {
                if (autobetRunning) {
                    editMinesToggle.checked = false;
                    messageEl.textContent = "Stop Autobet before editing mines. üõë";
                    messageEl.classList.add('lose');
                    return;
                }
                if (!gameOver) {
                    editMinesToggle.checked = false;
                    messageEl.textContent = "End current game before editing mines. üõë";
                    messageEl.classList.add('lose');
                    return;
                }
                if (selectingAutobetSquares) {
                    editMinesToggle.checked = false;
                    messageEl.textContent = "Exit Autobet Selection before editing mines. üõë";
                    messageEl.classList.add('lose');
                    return;
                }

                enableGameControls(false); // Temporarily disable all controls
                updateGridEventListeners(); // Change grid listener to edit mode
                
                generateGrid(); // Re-generate grid to show indicators
                customMinePositions.clear();
                minesCountSelect.value = 0;

                messageEl.textContent = "Edit Mines: Click cells to toggle mines. ‚úèÔ∏è";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');

            } else {
                enableGameControls(true);
                updateGridEventListeners(); // Change grid listener back to game mode
                minesCountSelect.disabled = false;
                
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    minesGridEl.children[i].classList.remove('dev-mine-indicator');
                }
                generateGrid(); // Re-generate grid to clear visual states and re-attach proper listener
                
                minesCountSelect.value = customMinePositions.size > 0 ? customMinePositions.size : 10;
                messageEl.textContent = `Edited mines: ${customMinePositions.size}. Ready to play! ‚úÖ`;
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            }
        }

        // Autobet Logic
        function toggleAutobetEnabled() {
            autobetEnabled = autobetToggle.checked;
            if (autobetEnabled) {
                messageEl.textContent = "Autobet enabled. Select squares or start! ü§ñ";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            } else {
                messageEl.textContent = "Autobet disabled. üò¥";
                messageEl.classList.remove('win');
                messageEl.classList.add('lose');
                if (autobetRunning) {
                    stopAutobet();
                }
                // When disabling autobet via toggle, also ensure selection mode is off
                if (selectingAutobetSquares) {
                    autobetToggleSelectionMode(false);
                    // selectAutobetSquaresButton.style.backgroundColor = ''; // This was for a visual toggle, removed for simplicity
                }
            }
            enableGameControls(true);
            updateGridEventListeners(); // Update grid listeners based on autobet enabled state
        }

        function autobetToggleSelectionMode(enable) {
            // If trying to enable and conditions prevent it, ensure selectingAutobetSquares is false
            if (enable) {
                if (!gameOver) {
                    messageEl.textContent = "End current game to select autobet squares. üõë";
                    messageEl.classList.add('lose');
                    selectingAutobetSquares = false; // Important: reset flag if couldn't enter mode
                    return;
                }
                if (editMinesActive) {
                    messageEl.textContent = "Exit 'Edit Mines' mode to select autobet squares. üõë";
                    messageEl.classList.add('lose');
                    selectingAutobetSquares = false; // Important: reset flag
                    return;
                }
                if (autobetRunning) {
                    messageEl.textContent = "Stop Autobet before selecting squares. üõë";
                    messageEl.classList.add('lose');
                    selectingAutobetSquares = false; // Important: reset flag
                    return;
                }
                // If all checks pass, then actually set selectingAutobetSquares to true
                selectingAutobetSquares = true;

                messageEl.textContent = "Click cells to select for Autobet. üéØ";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
                
                updateGridEventListeners(); // Change grid listener to selection mode
                
                // Re-apply visual if cells were already selected when *entering* selection mode
                selectedAutobetSquares.forEach(index => {
                    minesGridEl.children[index].classList.add('autobet-selected');
                });
                enableGameControls(false); // Disable game controls while selecting
                selectAutobetSquaresButton.disabled = false; // Keep this button enabled
                clearAutobetSelectionButton.disabled = false; // Keep this button enabled
                startAutobetButton.disabled = true; // Disable start autobet
                stopAutobetButton.disabled = true; // Disable stop autobet
                autobetToggle.disabled = true; // Disable main autobet toggle
            } else {
                // This block executes when disabling selection mode
                selectingAutobetSquares = false; // Ensure flag is false

                messageEl.textContent = "Autobet selection complete. ‚úÖ";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
                
                // --- FIX: Ensure all autobet-selected classes are removed when exiting mode ---
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    minesGridEl.children[i].classList.remove('autobet-selected');
                }
                // --- END FIX ---

                updateGridEventListeners(); // Change grid listener back to game mode
                enableGameControls(true); // Re-enable general game controls
                autobetToggle.disabled = false; // Enable main autobet toggle
            }
        }

        function clearAutobetSelection() {
            selectedAutobetSquares.forEach(index => {
                minesGridEl.children[index].classList.remove('autobet-selected');
            });
            selectedAutobetSquares.clear();
            selectedAutobetCount.textContent = 0;
            messageEl.textContent = "Autobet selection cleared. üßπ";
            messageEl.classList.remove('lose');
            messageEl.classList.add('win');
            enableGameControls(true);
            updateGridEventListeners(); // Update grid listeners
        }

        async function startAutobet() {
            if (autobetRunning) {
                messageEl.textContent = "Autobet already running. ü§∑‚Äç‚ôÄÔ∏è";
                messageEl.classList.add('lose');
                return;
            }
            if (selectedAutobetSquares.size === 0) {
                messageEl.textContent = "Select squares for Autobet first! ü§¶‚Äç‚ôÄÔ∏è";
                messageEl.classList.add('lose');
                return;
            }
            if (!gameOver) {
                messageEl.textContent = "End current game before starting autobet. üõë";
                messageEl.classList.add('lose');
                return;
            }
            if (editMinesActive) {
                messageEl.textContent = "Exit 'Edit Mines' mode before starting autobet. üõë";
                messageEl.classList.add('lose');
                return;
            }
            if (selectingAutobetSquares) {
                // If trying to start autobet while in selection mode, exit selection mode first.
                autobetToggleSelectionMode(false); 
                messageEl.textContent = "Autobet Selection exited. Now starting Autobet. üöÄ";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
                // Give a moment for UI update if desired, then proceed.
                await new Promise(resolve => setTimeout(resolve, 50)); 
            }

            autobetRunning = true;
            autobetStopping = false; // Ensure this is false when starting
            enableGameControls(false);
            updateGridEventListeners(); // Grid should not be clickable during autobet
            stopAutobetButton.disabled = false;

            messageEl.textContent = "Autobet started! Good luck! üçÄ";
            messageEl.classList.remove('lose');
            messageEl.classList.add('win');

            await autobetLoop();
        }

        async function autobetLoop() {
            // Immediate check for stopping sequence
            if (!autobetRunning || autobetStopping) {
                messageEl.textContent = "Autobet stopped. ‚è∏Ô∏è";
                messageEl.classList.add('lose');
                enableGameControls(true);
                updateGridEventListeners();
                return; // Exit immediately
            }
            
            // If a game is active, ensure it's ended before starting a new autobet round.
            // This handles cases where manual play or dev tools might have left a game running.
            if (!gameOver) {
                // If current game is ongoing, and it's not a win state after all cells revealed, it's a loss.
                // We're forcing an end to ensure a clean slate for the next autobet round.
                endGame(false); 
                await new Promise(resolve => setTimeout(resolve, AUTOBET_CLICK_DELAY)); // Small delay for UI update
            }

            const gameStarted = startGame();
            if (!gameStarted) {
                stopAutobet(); // Stop autobet if starting a new game fails
                messageEl.textContent = "Autobet stopped due to game start failure.üòû";
                messageEl.classList.add('lose');
                return;
            }

            await new Promise(resolve => setTimeout(resolve, AUTOBET_ROUND_DELAY));

            // Check again after round start delay
            if (!autobetRunning || autobetStopping) { return; }

            const selectedIndicesArray = Array.from(selectedAutobetSquares);
            let mineHitInRound = false;

            for (let i = 0; i < selectedIndicesArray.length; i++) {
                const index = selectedIndicesArray[i];
                if (!autobetRunning || gameOver || autobetStopping) { // Check flags before each click
                    // If autobet is stopped or game ends (e.g., manual intervention, previous mine hit within the same loop)
                    mineHitInRound = true; // Set to true to prevent further clicks/collection in this round
                    break; // Exit the click loop
                }
                const result = revealCell(index);
                if (!result) { // If a mine was hit
                    mineHitInRound = true;
                    // messageEl.textContent will be set by endGame(false) inside revealCell
                    break; // Stop clicking if a mine is hit
                }
                await new Promise(resolve => setTimeout(resolve, AUTOBET_CLICK_DELAY));
            }

            // After all clicks (or early break due to mine/stop)
            if (autobetRunning && !autobetStopping) { // Ensure autobet is still active and not manually stopping
                if (!mineHitInRound && revealedGems === selectedAutobetSquares.size && !gameOver) {
                    // All selected squares revealed and no mine hit and game still active (not ended by revealCell)
                    collectWinnings();
                    await new Promise(resolve => setTimeout(resolve, AUTOBET_CLICK_DELAY)); // Delay after collection message
                } else if (mineHitInRound && gameOver) {
                    // This means a mine was hit during the clicks. The game is already over (loss).
                    // Message is already set by endGame. We just need to reset for the next round.
                    await new Promise(resolve => setTimeout(resolve, AUTOBET_CLICK_DELAY)); // Small delay for UI
                }
                // Schedule the next round
                autobetTimeoutId = setTimeout(autobetLoop, AUTOBET_ROUND_DELAY);
            } else {
                // If autobetRunning is false or autobetStopping is true, it means stopAutobet was called.
                // The stopAutobet function already handles re-enabling controls and message.
            }
        }

        function stopAutobet() {
            autobetStopping = true; // Signal immediate stop
            autobetRunning = false;
            clearTimeout(autobetTimeoutId);
            messageEl.textContent = "Autobet stopped. üõë";
            messageEl.classList.add('lose');
            enableGameControls(true);
            updateGridEventListeners(); // Re-enable grid clicking for manual play
            // Ensure all visual indicators are cleared immediately
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                minesGridEl.children[i].classList.remove('show-mine', 'dev-mine-indicator', 'autobet-selected');
            }
            generateGrid(); // Re-generate grid to clear visual states (if any lingering)
            autobetStopping = false; // Reset flag after full stop sequence
        }


        // Event Listeners
        startGameButton.addEventListener('click', startGame);
        collectButton.addEventListener('click', collectWinnings);

        // Dev Mode Event Listeners
        unlockDevModeButton.addEventListener('click', unlockDevMode);
        devModePasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                unlockDevMode();
            }
        });
        giveCoinsButton.addEventListener('click', () => window.addCoins(1000));
        setCoinsButton.addEventListener('click', setCoinsTo);
        showMinesToggle.addEventListener('change', () => toggleShowMinesVisual(showMinesToggle.checked));
        editMinesToggle.addEventListener('change', toggleEditMinesMode);
        easyModeButton.addEventListener('click', () => {
            if (devMode) {
                const isActive = easyModeButton.dataset.active === 'true';
                easyModeButton.dataset.active = isActive ? 'false' : 'true';
                easyModeButton.style.backgroundColor = isActive ? '' : '#4299e1';
                messageEl.textContent = isActive ? "Easy Mode Deactivated." : "Easy Mode Activated! Next game will have 1 mine. üåü";
                messageEl.classList.remove('lose');
                messageEl.classList.add('win');
            }
        });
        instantRevealAllButton.addEventListener('click', instantRevealAll); // New
        forceWinButton.addEventListener('click', forceWin); // New
        forceLoseButton.addEventListener('click', forceLose); // New
        luckyMineToggle.addEventListener('change', () => { // NEW: Lucky Mine Toggle Listener
            luckyMineForAutobetActive = luckyMineToggle.checked;
            messageEl.textContent = luckyMineForAutobetActive ? "Lucky Mine (Autobet) Activated. üòà" : "Lucky Mine (Autobet) Deactivated. üòá";
            messageEl.classList.remove('lose', 'win');
            if (luckyMineForAutobetActive) messageEl.classList.add('lose'); else messageEl.classList.add('win');
        });


        // Autobet Event Listeners
        autobetToggle.addEventListener('change', toggleAutobetEnabled);
        selectAutobetSquaresButton.addEventListener('click', () => {
            // Toggle the selection mode
            autobetToggleSelectionMode(!selectingAutobetSquares);
        });
        clearAutobetSelectionButton.addEventListener('click', clearAutobetSelection);
        startAutobetButton.addEventListener('click', startAutobet);
        stopAutobetButton.addEventListener('click', stopAutobet);


        // Initial setup
        updateCoinDisplay();
        generateGrid();
        updateDisplays();
        enableGameControls(true); // Call to set initial button states
    </script>
</body>
</html>